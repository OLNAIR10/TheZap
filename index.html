

<!DOCTYPE html>

<html lang="pt-BR">

<head>

<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">Â 

<title>Chat de VÃ­deos - WhatsApp Style (WebRTC via Supabase)</title>


<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>


<style>

/* Estilos baseados no WhatsApp para mobile */

:root{ --bg:#e5ddd5; --panel:#fff; --my:#dcf8c6; --accent:#25d366; --header:#075e54; --dark:#111; }

body{Â 

Â  Â  margin:0;Â 

Â  Â  background:var(--bg);Â 

Â  Â  font-family:Arial, sans-serif;Â 

Â  Â  height: 100vh;

Â  Â  height: 100dvh;Â 

Â  Â  display:flex;Â 

Â  Â  flex-direction:column;Â 

Â  Â  overflow:hidden;Â 

}

#topbar{ height:56px; background:var(--header); display:flex; align-items:center; padding:0 12px; color:#fff; font-size:18px; font-weight:bold; justify-content: space-between; position: relative; }


/* Garante que o container de mensagens use o espaÃ§o restante */

#messages-container{Â 

Â  Â  flex:1;Â 

Â  Â  position: relative;Â 

Â  Â  display:flex;Â 

Â  Â  flex-direction:column;

}


/* Faz com que a Ã¡rea de mensagens role e use o espaÃ§o do container */

#messages{Â 

Â  Â  flex:1;Â 

Â  Â  overflow-y:auto;Â 

Â  Â  padding:0 10px 10px 10px;Â 

Â  Â  display:flex;Â 

Â  Â  flex-direction:column;Â 

Â  Â  scroll-behavior:smooth;Â 

Â  Â  background-color:var(--bg);Â 

Â  Â  padding-top: 10px;

Â  Â  background-size: cover;Â 

Â  Â  background-position: center;Â 

}

/* Estilo para o grupo de mensagem e nome do perfil */

.msg-group {

Â  Â  display: flex;

Â  Â  flex-direction: column;

Â  Â  max-width: 80%;

Â  Â  margin-bottom: 8px;Â 

}

.msg-group.meÂ {

Â  Â  align-self: flex-end;

}

.msg-group.other {

Â  Â  align-self: flex-start;

}

/* Estilo para o nome do perfil (e-mail) */

.profile-name {

Â  Â  font-size: 12px;

Â  Â  color: #075e54;Â 

Â  Â  margin-bottom: 2px;

Â  Â  align-self: flex-start;

Â  Â  padding-left: 8px;

Â  Â  font-weight: bold;

}

.msg-group.meÂ .profile-name {

Â  Â  color: #128C7E;

Â  Â  align-self: flex-end;

Â  Â  padding-right: 8px;

Â  Â  padding-left: 0;

}

.msg{Â 

Â  Â  max-width:100%;Â 

Â  Â  padding:8px 12px;Â 

Â  Â  margin-bottom:2px;Â 

Â  Â  border-radius:8px;Â 

Â  Â  font-size:15px;Â 

Â  Â  line-height:1.3;Â 

Â  Â  position: relative;

Â  Â  padding-right: 50px;Â 

Â  Â  cursor: pointer;Â 

}

.me{ align-self:flex-end; background:var(--my);Â 

Â  Â  border-bottom-right-radius: 0;Â 

}

.other{ align-self:flex-start; background:#fff;Â 

Â  Â  border-bottom-left-radius: 0;Â 

}

/* Estilo do horÃ¡rio */

.timestamp {

Â  Â  position: absolute;

Â  Â  bottom: 2px;

Â  Â  right: 8px;

Â  Â  font-size: 10px;

Â  Â  color: rgba(0, 0, 0, 0.4);

}

/* Garante rodapÃ© fixo no mobile e considera barra de gesto */

#inputArea{Â 

Â  Â  height:60px;Â 

Â  Â  background:#fff;Â 

Â  Â  display:flex;Â 

Â  Â  align-items:center;Â 

Â  Â  padding:0 6px;Â 

Â  Â  gap:6px;Â 

Â  Â  width: 100%;

Â  Â  box-sizing: border-box;Â 

Â  Â  padding-bottom: env(safe-area-inset-bottom);Â 

}

#textInput{ flex:1; height:40px; border:1px solid #ccc; border-radius:20px; padding:0 14px; font-size:15px; }

.btn{ width:42px; height:42px; border-radius:50%; display:flex; align-items:center; justify-content:center; background:var(--accent); border:none; color:#fff; cursor:pointer;Â 

Â  Â  font-size: 18px;Â 

}

.menu-item {

Â  Â  display: block;

Â  Â  padding: 10px 15px;

Â  Â  text-decoration: none;

Â  Â  color: var(--dark);

}

.menu-item:hover {

Â  Â  background-color: #f0f0f0;

}

#videoCallArea{Â 

Â  Â  position:absolute; top:0; left:0; width:100%; height:100%;Â 

Â  Â  background:rgba(0,0,0,0.9); z-index:10;Â 

Â  Â  display:none; flex-direction: column; justify-content:center; align-items:center;Â 

}

#localVideo{Â 

Â  Â  width:100%; height:100%; object-fit:cover;Â 

}

#hangupBtn{Â 

Â  Â  position:absolute; bottom:20px; background:red; color:white;Â 

Â  Â  font-size:24px; border-radius:30px; padding:8px 24px; border:none; cursor:pointer;Â 

}

#loginModal{ position:fixed; top:0; left:0; width:100%; height:100%; background:#fff; z-index:9999; padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center; }

.file-content {

Â  Â  margin: 4px 0;

}

.file-content img, .file-content video {

Â  Â  display: block;

Â  Â  max-width: 100%;Â 

Â  Â  height: auto;

}

</style>

</head>

<body>


<div id="topbar">

Â  <div id="topbar-left"><span id="chatTitle">Chat VÃ­deos</span></div>

Â  <button id="kebabBtn">â‹®</button>

Â  <div id="kebabMenu" style="display:none; position:absolute; top:50px; right:5px; background:white; border-radius:4px; box-shadow:0 2px 5px rgba(0,0,0,0.2); min-width:200px; z-index:1000;">

Â  Â  <a href="contacts.html" class="menu-item">ğŸ‘¥ Contatos</a>

Â  Â  <a href="#" class="menu-item" onclick="chooseWallpaper()">ğŸ–¼ï¸ Trocar Fundo de Tela</a>

Â  Â  <a href="#" class="menu-item" onclick="deleteAllMessages()">ğŸ—‘ï¸ Apagar TODAS as Mensagens</a>

Â  Â  <a href="#" class="menu-item" onclick="logout()">Sair</a>

Â  </div>

</div>


<div id="messages-container">

Â  <div id="videoCallArea">

Â  Â  <video id="localVideo" autoplay playsinline muted></video>

Â  Â  <button id="hangupBtn" onclick="hangUpCall()">ğŸ“ Desligar</button>

Â  Â  <p style="position:absolute; top:10px; color:white; font-weight:bold;">Videochamada WebRTC</p>

Â  Â  <video id="remoteVideo" autoplay playsinline style="width: 100px; height: 100px; position: absolute; top: 10px; right: 10px; z-index: 100; border-radius: 8px; border: 2px solid white; display:none;"></video>

Â  </div>

Â  <div id="messages"></div>

</div>


<div id="inputArea">

Â  <button id="fileBtn" class="btn">ğŸ“</button>

Â  <input type="file" id="wallpaperInput" accept="image/*" style="display:none">Â 

Â  <input type="file" id="fileInput" accept="video/*,image/*" style="display:none">

Â  <button id="videoCallBtn" class="btn" title="Iniciar Videochamada">ğŸ“¹</button>

Â  <input id="textInput" placeholder="Mensagem">

Â  <button id="micBtn" class="btn">ğŸ¤</button>

Â  <button id="sendBtn" class="btn">â¤</button>

</div>


<div id="loginModal">

Â  <div style="width:100%;max-width:320px;">

Â  Â  <h2>Entrar</h2>

Â  Â  <input id="email" placeholder="Email (seu nome de perfil)" style="width:100%;padding:10px;margin:6px 0;border-radius:6px;border:1px solid #ccc;">

Â  Â  <input id="pass" placeholder="Senha" type="password" style="width:100%;padding:10px;margin:6px 0;border-radius:6px;border:1px solid #ccc;">

Â  Â  <button onclick="login()">Entrar</button>

Â  Â  <button onclick="register()">Registrar</button>

Â  Â  <button onclick="reset()">Esqueci a senha</button>

Â  Â  <p style="font-size:13px;color:#666;margin-top:10px;">ObservaÃ§Ã£o: teste em <strong>localhost</strong> ou via <em>HTTPS</em>. Chrome bloqueia cÃ¢mera/microfone em contexto inseguro.</p>

Â  </div>

</div>


<script>

/* ---------- CONFIGURAÃ‡ÃƒO SUPABASE (NOVAS CHAVES) ---------- */

const SUPABASE_URL = "https://rtbfafyckvjexabywztu.supabase.co";Â 

const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ0YmZhZnlja3ZqZXhhYnl3enR1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4MTg4MDYsImV4cCI6MjA4MDM5NDgwNn0.pemzzt-0MNF1wxVVtM13n5rgWCu8mSmdF_GQU4TrMM4";


const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {

Â  auth: { persistSession: true }

});


/* ---------- VariÃ¡veis Globais de Estado e WebRTC ---------- */

let user = null;

let localStream = null;

let messagesDiv = document.getElementById('messages');

const loginModal = document.getElementById('loginModal');

const emailInput = document.getElementById('email');

const passInput = document.getElementById('pass');

const textInput = document.getElementById('textInput');

const fileInput = document.getElementById('fileInput');

const wallpaperInput = document.getElementById('wallpaperInput');Â 

const videoCallArea = document.getElementById('videoCallArea');

const localVideo = document.getElementById('localVideo');


let peerConnection = null; // Objeto RTCPeerConnection

let remoteVideo = null; // Elemento para o vÃ­deo do outro par

let callChannel = null; // Canal Supabase para a sinalizaÃ§Ã£o

let autoCallTargetId = null; // ID de destino para chamada automÃ¡tica via URL


// --- INÃCIO DA REVISÃƒO DOS iceServers ---

const iceServers = {

Â  Â  iceServers: [

Â  Â  Â  Â  // STUN Servers (Aumentamos a lista para maior confiabilidade P2P)

Â  Â  Â  Â  { urls: 'stun:stun.l.google.com:19302' },

Â  Â  Â  Â  { urls: 'stun:stun.services.mozilla.com' },

Â  Â  Â  Â  { urls: 'stun:stun.stunprotocol.org' },

Â  Â  Â  Â  { urls: 'stun:stun.voipbuster.com' },

Â  Â  Â  Â  { urls: 'stun:stun.callwithus.com' },

Â  Â  Â  Â Â 

Â  Â  Â  Â  // TURN Servers (Mantidos como fallback para redes restritivas)

Â  Â  Â  Â  // Nota: Estes sÃ£o servidores TURN PÃšBLICOS e GRATUITOS para TESTES.Â 

Â  Â  Â  Â  // Para PRODUÃ‡ÃƒO, Ã© ALTAMENTE recomendado usar um serviÃ§o TURN pago e dedicado para estabilidade.

Â  Â  Â  Â  {

Â  Â  Â  Â  Â  Â  urls: 'turn:openrelay.metered.ca:443?transport=tcp',Â 

Â  Â  Â  Â  Â  Â  username: 'openrelayproject',

Â  Â  Â  Â  Â  Â  credential: 'openrelayproject'

Â  Â  Â  Â  },

Â  Â  Â  Â  {

Â  Â  Â  Â  Â  Â  urls: 'turn:openrelay.metered.ca:443?transport=udp',Â 

Â  Â  Â  Â  Â  Â  username: 'openrelayproject',

Â  Â  Â  Â  Â  Â  credential: 'openrelayproject'

Â  Â  Â  Â  }

Â  Â  ]

};

// --- FIM DA REVISÃƒO DOS iceServers ---


// Obter elemento remoto (jÃ¡ estÃ¡ no HTML)

remoteVideo = document.getElementById('remoteVideo');



// Adiciona funcionalidade aos botÃµes

document.getElementById('fileBtn').onclick = () => { if(!user){ alert('FaÃ§a login primeiro'); return; } fileInput.click(); };

document.getElementById('micBtn').onclick = () => { if(!user){ alert('FaÃ§a login primeiro'); return; } alert('SimulaÃ§Ã£o de gravaÃ§Ã£o de Ã¡udio...'); };

fileInput.onchange = (e) => { if(e.target.files[0]) uploadFile(e.target.files[0]); };

document.getElementById('sendBtn').onclick = sendMessage;

textInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendMessage(); });


// LÃ³gica atualizada para o botÃ£o de chamada: verifica login primeiro

document.getElementById('videoCallBtn').onclick = () => {

Â  Â  if(!user){

Â  Â  Â  Â  alert('FaÃ§a login para iniciar uma videochamada.');

Â  Â  Â  Â  return;

Â  Â  }

Â  Â  let target = autoCallTargetId;Â 

Â  Â  if (!target) {

Â  Â  Â  Â  // Redireciona para a pÃ¡gina de contatos se nÃ£o houver alvo na URL.

Â  Â  Â  Â  alert("Selecione um contato na lista de 'Contatos' para iniciar uma chamada.");

Â  Â  Â  Â  window.location.href = 'contacts.html';Â 

Â  Â  Â  Â  return;

Â  Â  }

Â  Â  startVideoCall(target);

};


document.getElementById('kebabBtn').onclick = () => { const m = document.getElementById('kebabMenu'); m.style.display = m.style.display === 'block' ? 'none' : 'block'; };

document.addEventListener('click', (e)=>{ const m=document.getElementById('kebabMenu'); if(e.target.id!=='kebabBtn' && !m.contains(e.target)) m.style.display='none'; });



/* ---------- FUNÃ‡Ã•ES AUXILIARES DE VIDEOCHAMADA ---------- */


// Lida com a chegada do stream de vÃ­deo/Ã¡udio do par remoto

function handleTrackEvent(event) {

Â  Â  if (remoteVideo && event.streams && event.streams[0]) {

Â  Â  Â  Â  remoteVideo.srcObject = event.streams[0];

Â  Â  Â  Â  remoteVideo.style.display = 'block';

Â  Â  Â  Â  console.log('Stream remoto recebido.');

Â  Â  }

}


// Lida com a descoberta de candidatos ICE (endereÃ§os de rede)

async function handleIceCandidateEvent(event, targetPeerId) {

Â  Â  if (event.candidate) {

Â  Â  Â  Â  console.log('Enviando candidato ICE:', event.candidate);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Envia o candidato ICE (endereÃ§o de rede) para o outro par via Broadcast

Â  Â  Â  Â  // Nota: O canal 'call_room_' + targetPeerId deve estar subscrito no lado do receptor.

Â  Â  Â  Â  await sb.channel('call_room_' + targetPeerId).send({

Â  Â  Â  Â  Â  Â  type: 'broadcast',

Â  Â  Â  Â  Â  Â  event: 'signal',

Â  Â  Â  Â  Â  Â  payload: {

Â  Â  Â  Â  Â  Â  Â  Â  senderId:Â user.id,

Â  Â  Â  Â  Â  Â  Â  Â  targetId: targetPeerId,

Â  Â  Â  Â  Â  Â  Â  Â  type: 'ice-candidate',

Â  Â  Â  Â  Â  Â  Â  Â  candidate: event.candidate

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });

Â  Â  }

}


// Lida com mensagens de sinalizaÃ§Ã£o recebidas via Supabase Broadcast

async function handleSignalMessage(payload) {

Â  Â  const signal = payload.payload;

Â  Â Â 

Â  Â  // Ignora sinais que nÃ£o sÃ£o relevantes ou se jÃ¡ estiver em chamada

Â  Â  if (signal.targetId !==Â user.id) return;Â 


Â  Â  console.log('Sinal recebido:', signal.type, signal);


Â  Â  if (signal.type === 'offer') {

Â  Â  Â  Â  // Se for uma oferta (o par estÃ¡ chamando)

Â  Â  Â  Â  // Se jÃ¡ estiver em uma chamada, rejeita

Â  Â  Â  Â  if(peerConnection){

Â  Â  Â  Â  Â  Â  console.log('JÃ¡ em chamada. Ignorando nova oferta.');

Â  Â  Â  Â  Â  Â  return;Â 

Â  Â  Â  Â  }


Â  Â  Â  Â  if (!confirm(`Chamada recebida de ${signal.senderId.substring(0, 8)}... Deseja atender?`)) {

Â  Â  Â  Â  Â  Â  console.log("Chamada recusada.");

Â  Â  Â  Â  Â  Â  return;Â 

Â  Â  Â  Â  }


Â  Â  Â  Â  // Inicializa o PC com o ID do remetente como alvo

Â  Â  Â  Â  await initializePeerConnection(signal.senderId);Â 

Â  Â  Â  Â  await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));

Â  Â  Â  Â  const answer = await peerConnection.createAnswer();

Â  Â  Â  Â  await peerConnection.setLocalDescription(answer);


Â  Â  Â  Â  // Envia a resposta de volta para o chamador

Â  Â  Â  Â  await sb.channel('call_room_' + signal.senderId).send({

Â  Â  Â  Â  Â  Â  type: 'broadcast',

Â  Â  Â  Â  Â  Â  event: 'signal',

Â  Â  Â  Â  Â  Â  payload: {

Â  Â  Â  Â  Â  Â  Â  Â  senderId:Â user.id,

Â  Â  Â  Â  Â  Â  Â  Â  targetId: signal.senderId,

Â  Â  Â  Â  Â  Â  Â  Â  type: 'answer',

Â  Â  Â  Â  Â  Â  Â  Â  sdp: peerConnection.localDescription

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });


Â  Â  } else if (signal.type === 'answer') {

Â  Â  Â  Â  // Se for a resposta, define como descriÃ§Ã£o remota

Â  Â  Â  Â  await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));


Â  Â  } else if (signal.type === 'ice-candidate') {

Â  Â  Â  Â  // Adiciona o candidato ICE

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  if(peerConnection && peerConnection.remoteDescription) {

Â  Â  Â  Â  Â  Â  Â  Â  Â await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  } catch (e) {

Â  Â  Â  Â  Â  Â  console.error('Erro ao adicionar candidato ICE:', e);

Â  Â  Â  Â  }

Â  Â  }

}


// FunÃ§Ã£o para inicializar o PeerConnection e obter mÃ­dia

async function initializePeerConnection(targetPeerId) {

Â  Â  if (peerConnection) return;

Â  Â Â 

Â  Â  // 1. Obter mÃ­dia local (MUDANÃ‡A: Fazemos aqui para garantir que a permissÃ£o Ã© pedida sÃ³ na chamada)

Â  Â  try {

Â  Â  Â  Â  localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

Â  Â  } catch(err) {

Â  Â  Â  Â  console.error('Erro ao acessar mÃ­dia (cÃ¢mera/microfone):', err);

Â  Â  Â  Â  alert('Erro ao acessar cÃ¢mera/microfone. Verifique as permissÃµes. ' + (err.message ||Â err.name));

Â  Â  Â  Â  return; // Sai se falhar ao obter a mÃ­dia

Â  Â  }

Â  Â Â 

Â  Â  // 2. Configurar PeerConnection

Â  Â  peerConnection = new RTCPeerConnection(iceServers);

Â  Â Â 

Â  Â  // 3. Configurar eventos

Â  Â  peerConnection.ontrack = handleTrackEvent;

Â  Â  // O evento de ICE agora precisa do targetPeerId para enviar a mensagem.

Â  Â  peerConnection.onicecandidate = (event) => handleIceCandidateEvent(event, targetPeerId);Â 


Â  Â  // 4. Exibir vÃ­deo local e adicionar tracks

Â  Â  localVideo.srcObject = localStream;

Â  Â  localVideo.muted = true;Â 

Â  Â  videoCallArea.style.display = 'flex';

Â  Â  localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

Â  Â Â 

Â  Â  remoteVideo.style.display = 'none'; // Esconde atÃ© receber o stream

Â  Â Â 

Â  Â  // Monitoramento do estado da conexÃ£o para diagnÃ³stico

Â  Â  peerConnection.onconnectionstatechange = (event) => {

Â  Â  Â  Â  console.log(`Estado da conexÃ£o WebRTC: ${peerConnection.connectionState}`);

Â  Â  Â  Â  if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {

Â  Â  Â  Â  Â  Â  Â console.error("A conexÃ£o WebRTC falhou ou foi desconectada.");

Â  Â  Â  Â  Â  Â  Â // Lembre-se que o hangUpCall() Ã© chamado quando o canal WebRTC Ã© fechado/perdido

Â  Â  Â  Â  }

Â  Â  };

}



/* ---------- VIDEOCHAMADA (WebRTC) - FUNÃ‡ÃƒO PRINCIPAL ATUALIZADA ---------- */

async function startVideoCall(targetPeerId){

Â  Â  if(!user || !targetPeerId){Â 

Â  Â  Â  Â  console.error('UsuÃ¡rio ou alvo nÃ£o definido.');

Â  Â  Â  Â  return;Â 

Â  Â  }


Â  Â  if(!isSecureContext()){

Â  Â  Â  Â  alert('O WebRTC requer HTTPS. Teste em localhost ou por HTTPS.');

Â  Â  Â  Â  return;

Â  Â  }


Â  Â  try{

Â  Â  Â  Â  // 1. Inicializa o PeerConnection e obtÃ©m a mÃ­dia

Â  Â  Â  Â  await initializePeerConnection(targetPeerId); // Passa o targetPeerId

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Se a inicializaÃ§Ã£o falhou (ex: sem permissÃ£o de mÃ­dia), sai.

Â  Â  Â  Â  if(!peerConnection) return;Â 


Â  Â  Â  Â  // 2. Criar e enviar a Oferta SDP (apenas o iniciador faz isso)

Â  Â  Â  Â  const offer = await peerConnection.createOffer();

Â  Â  Â  Â  await peerConnection.setLocalDescription(offer);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Envia a oferta para o canal do usuÃ¡rio que vocÃª estÃ¡ ligando

Â  Â  Â  Â  await sb.channel('call_room_' + targetPeerId).send({

Â  Â  Â  Â  Â  Â  type: 'broadcast',

Â  Â  Â  Â  Â  Â  event: 'signal',

Â  Â  Â  Â  Â  Â  payload: {

Â  Â  Â  Â  Â  Â  Â  Â  senderId:Â user.id,

Â  Â  Â  Â  Â  Â  Â  Â  targetId: targetPeerId,

Â  Â  Â  Â  Â  Â  Â  Â  type: 'offer',

Â  Â  Â  Â  Â  Â  Â  Â  sdp: peerConnection.localDescription

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });


Â  Â  Â  Â  alert(`Chamada iniciada. Tentando conectar com ${targetPeerId.substring(0, 8)}...`);


Â  Â  }catch(err){

Â  Â  Â  Â  console.error('Erro ao iniciar WebRTC:', err);

Â  Â  Â  Â  alert('Erro ao iniciar chamada: ' + (err.message ||Â err.name));

Â  Â  Â  Â  hangUpCall();

Â  Â  }

}


function hangUpCall(){

Â  Â  // Fecha a conexÃ£o P2P

Â  Â  if(peerConnection){

Â  Â  Â  Â  peerConnection.close();

Â  Â  Â  Â  peerConnection = null;

Â  Â  }

Â  Â Â 

Â  Â  if(localStream){

Â  Â  Â  Â  localStream.getTracks().forEach(t => t.stop());

Â  Â  Â  Â  localStream = null;

Â  Â  Â  Â  localVideo.srcObject = null;

Â  Â  }

Â  Â  if(remoteVideo){

Â  Â  Â  Â  remoteVideo.srcObject = null;

Â  Â  Â  Â  remoteVideo.style.display = 'none';

Â  Â  }

Â  Â  videoCallArea.style.display = 'none';

Â  Â  console.log('Chamada encerrada.');

Â  Â Â 

Â  Â  // Limpa o target da URL apÃ³s desligar (para evitar recarregar e ligar de novo)

Â  Â  history.pushState(null, '', window.location.pathname);

Â  Â  autoCallTargetId = null;Â 

}

window.hangUpCall = hangUpCall; // Torna global para o botÃ£o


/* ---------- OUTRAS FUNÃ‡Ã•ES (NÃ£o relacionadas a WebRTC) ---------- */

function chooseWallpaper() {

Â  Â  if(!user){ alert('FaÃ§a login primeiro'); return; }

Â  Â  wallpaperInput.click();

}

window.chooseWallpaper = chooseWallpaper;


wallpaperInput.onchange = (e) => {

Â  Â  const file = e.target.files[0];

Â  Â  if (file) {

Â  Â  Â  Â  const reader = new FileReader();

Â  Â  Â  Â  reader.onload = (e) => {

Â  Â  Â  Â  Â  Â  messagesDiv.style.backgroundImage = `url('${e.target.result}')`;

Â  Â  Â  Â  Â  Â  alert('Fundo de tela alterado!');

Â  Â  Â  Â  };

Â  Â  Â  Â  reader.readAsDataURL(file);

Â  Â  }

};


/* ---------- UTIL: checar se estamos em contexto seguro ---------- */

function isSecureContext() {

Â  return window.isSecureContext || location.hostname === "localhost" || location.hostname === "127.0.0.1";

}


/* ---------- AUTENTICAÃ‡ÃƒO ---------- */

async function login(){

Â  const email = emailInput.value.trim();

Â  const pass = passInput.value;

Â  if(!email || !pass){ alert('Preencha email e senha.'); return; }

Â  const { data, error } = await sb.auth.signInWithPassword({ email, password: pass });

Â  if(error){ alert('Erro: ' + (error.message || JSON.stringify(error))); return; }

Â  user = data.user;

Â  initializeChat();

}


async function register(){

Â  const email = emailInput.value.trim();

Â  const pass = passInput.value;

Â  if(!email.includes('@')){ alert('Email invÃ¡lido'); return; }

Â  const { data, error } = await sb.auth.signUp({ email, password: pass });

Â  if(error){ alert('Erro no registro: ' + (error.message || JSON.stringify(error))); }

Â  else { alert('Registrado! Confirme o email e faÃ§a login.'); }

}


async function reset(){

Â  const email = emailInput.value.trim();

Â  if(!email.includes('@')){ alert('Email invÃ¡lido'); return; }

Â  const { data, error } = await sb.auth.resetPasswordForEmail(email);

Â  if(error) alert('Erro: ' + (error.message || JSON.stringify(error)));

Â  else alert('Email de recuperaÃ§Ã£o enviado!');

}


async function logout(){

Â  const { error } = await sb.auth.signOut();

Â  if(error) alert('Erro ao sair: ' + error.message);

Â  user = null;

Â  messagesDiv.innerHTML = '';

Â  loginModal.style.display = 'flex';

Â  document.getElementById('chatTitle').textContent = 'Chat VÃ­deos';

Â  messagesDiv.style.backgroundImage = ''; // Limpa o fundo ao sair

Â  hangUpCall(); // Garante que a chamada seja desligada

}

window.logout = logout; // Torna global


/* ---------- EXCLUSÃƒO DE MENSAGENS INDIVIDUAL ---------- */

window.openMessageMenu = function(e, msg) {

Â  Â  if(!user || msg.user_id !==Â user.id) return;Â 


Â  Â  // SubstituÃ­do por modal/confirmaÃ§Ã£o customizada em uma aplicaÃ§Ã£o real.

Â  Â  const confirmed = confirm(`Deseja apagar esta mensagem (ID: ${msg.id})?`);Â 

Â  Â  if (confirmed) {

Â  Â  Â  Â  deleteMessage(msg.id);

Â  Â  }

Â  Â  e.stopPropagation();Â 

};


async function deleteMessage(messageId){

Â  Â  if(!user) return;


Â  Â  const { error } = await sb.from('messages')

Â  Â  Â  Â  .delete()

Â  Â  Â  Â  .eq('id', messageId)

Â  Â  Â  Â  .eq('user_id',Â user.id);Â 


Â  Â  if(error){Â 

Â  Â  Â  Â  alert('Erro ao apagar mensagem: ' + error.message);

Â  Â  Â  Â  console.error(error);

Â  Â  } else {

Â  Â  Â  Â  const el = document.querySelector(`[data-message-id="${messageId}"]`);

Â  Â  Â  Â  if(el) {

Â  Â  Â  Â  Â  Â  const groupEl = el.closest('.msg-group');

Â  Â  Â  Â  Â  Â  if(groupEl) groupEl.remove();

Â  Â  Â  Â  }

Â  Â  }

}

window.deleteMessage = deleteMessage;


/* ---------- EXCLUSÃƒO EM MASSA DE MENSAGENS ---------- */

async function deleteAllMessages(){

Â  Â  if(!user){

Â  Â  Â  Â  alert('FaÃ§a login primeiro.');

Â  Â  Â  Â  return;

Â  Â  }

Â  Â Â 

Â  Â  // SubstituÃ­do por modal/confirmaÃ§Ã£o customizada em uma aplicaÃ§Ã£o real.

Â  Â  const confirmed = confirm("âš ï¸ ATENÃ‡ÃƒO: Deseja REALMENTE apagar TODAS as suas mensagens no chat? Esta aÃ§Ã£o Ã© irreversÃ­vel.");

Â  Â  if (!confirmed) return;

Â  Â Â 

Â  Â  const { error } = await sb.from('messages')

Â  Â  Â  Â  .delete()

Â  Â  Â  Â  .eq('user_id',Â user.id);Â 


Â  Â  if(error){Â 

Â  Â  Â  Â  alert('Erro ao apagar mensagens: ' + error.message);

Â  Â  Â  Â  console.error(error);

Â  Â  } else {

Â  Â  Â  Â  messagesDiv.innerHTML = '';

Â  Â  Â  Â  alert('Todas as suas mensagens foram apagadas com sucesso! (Recarregue para garantir a sincronizaÃ§Ã£o em tempo real).');

Â  Â  }

}

window.deleteAllMessages = deleteAllMessages; // Torna global



/* ---------- RENDER MENSAGENS ---------- */

function renderMessage(msg){

Â  const date = new Date(msg.created_at);

Â  const timeString = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

Â  const profileName = msg.user_id ===Â user.idÂ ? 'VocÃª' : (msg.email || msg.user_id);Â 

Â Â 

Â  const groupDiv = document.createElement('div');

Â  groupDiv.className = 'msg-group ' + ((user && msg.user_id ===Â user.id) ? 'me':'other');


Â  // Adiciona o nome do perfil

Â  const nameSpan = document.createElement('span');

Â  nameSpan.className = 'profile-name';

Â  nameSpan.textContent = profileName;Â 

Â  groupDiv.appendChild(nameSpan);


Â  const div = document.createElement('div');

Â  div.className = 'msg ' + ((user && msg.user_id ===Â user.id) ? 'me':'other');

Â Â 

Â  div.dataset.messageId =Â msg.id;Â 

Â  div.onclick = (e) => openMessageMenu(e, msg);



Â  let content = msg.text || '';

Â  const prefixes = { '[Ãudio]:':'audio', '[Imagem]:':'image', '[VÃ­deo]:':'video', '[Arquivo]:':'file' };

Â  for(const p in prefixes){

Â  Â  if(content.startsWith(p)){

Â  Â  Â  const type = prefixes[p];

Â  Â  Â  const path = content.substring(p.length).trim();

Â  Â  Â  const { data: urlData } = sb.storage.from('chat-media').getPublicUrl(path);

Â  Â  Â  const fileUrl = urlData.publicUrl;

Â  Â  Â  if(type === 'image') {

Â  Â  Â  Â  content = `<div class="file-content">ğŸ–¼ï¸ <a href="${fileUrl}" target="_blank"><img src="${fileUrl}" alt="imagem" style="max-width:220px;border-radius:6px"></a></div>`;

Â  Â  Â  } else if(type === 'video') {

Â  Â  Â  Â  content = `<div class="file-content">ğŸ“¹<video controls style="max-width:240px;border-radius:6px"><source src="${fileUrl}">Seu navegador nÃ£o suporta.</video></div>`;

Â  Â  Â  } else if(type === 'audio') {

Â  Â  Â  Â  content = `<div class="file-content">ğŸ¤<audio controls src="${fileUrl}" style="max-width:240px"></audio></div>`;

Â  Â  Â  } else {

Â  Â  Â  Â  const fileName = path.split('/').pop();

Â  Â  Â  Â  content = `<div class="file-content">ğŸ“¦ <a href="${fileUrl}" target="_blank" download>${fileName}</a></div>`;

Â  Â  Â  }

Â  Â  Â  break;

Â  Â  }

Â  }


Â  div.innerHTML = `${content}<span class="timestamp">${timeString}</span>`;

Â  groupDiv.appendChild(div);

Â Â 

Â  messagesDiv.appendChild(groupDiv);

Â  messagesDiv.scrollTop = messagesDiv.scrollHeight;

}


/* ---------- INSERIR E CARREGAR HISTÃ“RICO ---------- */

async function sendMessage(){

Â  const text = textInput.value.trim();

Â  if(!text || !user) return;

Â  const { error } = await sb.from('messages').insert({ user_id:Â user.id, text, email: user.email });Â 

Â  if(error) alert('Erro ao enviar: ' + error.message);

Â  else textInput.value = '';

}


async function loadHistory(){

Â  const { data, error } = await sb.from('messages').select('*').order('created_at', { ascending: true });

Â  if(error){ console.error(error); alert('Erro ao carregar histÃ³rico'); return; }

Â  messagesDiv.innerHTML = '';

Â  data.forEach(renderMessage);

}


/* ---------- SUBSCRIBE (Realtime) ---------- */

function subscribeToMessages(){

Â  if(window.chatChannel) sb.removeChannel(window.chatChannel);

Â  window.chatChannel = sb.channel('public:messages')

Â  Â  .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {

Â  Â  Â  if(payload &&Â payload.new) renderMessage(payload.new);

Â  Â  })

Â  Â  .subscribe();

}


/* ---------- UPLOAD ---------- */

async function uploadFile(file){

Â  if(!file || !user) return;

Â  const mimeType = file.type || '';

Â  let prefix = '[Arquivo]: ';

Â  if(mimeType.startsWith('video/')) prefix = '[VÃ­deo]: ';

Â  else if(mimeType.startsWith('image/')) prefix = '[Imagem]: ';

Â Â 

Â  const safeName = file.name.replace(/[^a-z0-9.]/gi, '_').toLowerCase();

Â  const path = `${user.id}/${Date.now()}_${safeName}`;

Â  const { data: uploadData, error: uploadError } = await sb.storage.from('chat-media').upload(path, file, { cacheControl: '3600', upsert: false, contentType: mimeType });

Â  if(uploadError){ console.error(uploadError); alert('Erro no upload: ' + uploadError.message); return; }

Â Â 

Â  const { error: dbError } = await sb.from('messages').insert({ user_id:Â user.id, text: `${prefix}${uploadData.path}`, email: user.email });Â 

Â  if(dbError) alert('Erro ao gravar mensagem: ' + dbError.message);

Â  fileInput.value = '';

}


// FunÃ§Ã£o para obter parÃ¢metros da URL

function getUrlParameter(name) {

Â  Â  name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');

Â  Â  const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');

Â  Â  const results = regex.exec(location.search);

Â  Â  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));

};


/* ---------- LÃ³gica de subscriÃ§Ã£o e inÃ­cio de chamada automÃ¡tica ---------- */

function setupCallChannelAndStartAutoCall() {

Â  Â  if (!user) return;Â 

Â  Â Â 

Â  Â  // 1. Assina o canal de sinalizaÃ§Ã£o do prÃ³prio usuÃ¡rio para receber ofertas e respostas

Â  Â  if (!callChannel) {

Â  Â  Â  Â  callChannel = sb.channel('call_room_' +Â user.id);

Â  Â  Â  Â  callChannel.on('broadcast', { event: 'signal' }, handleSignalMessage).subscribe((status) => {

Â  Â  Â  Â  Â  Â  if (status === 'SUBSCRIBED') {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`Pronto para receber chamadas no canal: call_room_${user.id}`);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Se houver um alvo no URL, inicia a chamada automaticamente AGORA QUE O CANAL ESTÃ PRONTO.

Â  Â  Â  Â  Â  Â  Â  Â  if (autoCallTargetId && autoCallTargetId !==Â user.id) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startVideoCall(autoCallTargetId);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });

Â  Â  } else {

Â  Â  Â  Â  // Se o canal jÃ¡ estava pronto, tenta iniciar a chamada se houver um alvo

Â  Â  Â  Â  if (autoCallTargetId && autoCallTargetId !==Â user.id) {

Â  Â  Â  Â  Â  Â  Â startVideoCall(autoCallTargetId);

Â  Â  Â  Â  }

Â  Â  }

}



/* ---------- INICIALIZAÃ‡ÃƒO ---------- */

function initializeChat(){

Â  // Checa se hÃ¡ um alvo de chamada no URL

Â  autoCallTargetId = getUrlParameter('target');

Â Â 

Â  sb.auth.getSession().then(({ data: { session } }) => {

Â  Â  if(session) user = session.user;

Â  Â Â 

Â  Â  if(user){

Â  Â  Â  loginModal.style.display = 'none';

Â  Â  Â  document.getElementById('chatTitle').textContent = user.email.split('@')[0];

Â  Â  Â  loadHistory();

Â  Â  Â  subscribeToMessages();

Â  Â  Â Â 

Â  Â  Â  // CHAVE: Configura o canal de recebimento e inicia a chamada automÃ¡tica

Â  Â  Â  if (autoCallTargetId ===Â user.id) {

Â  Â  Â  Â  Â  alert("VocÃª nÃ£o pode ligar para si mesmo.");

Â  Â  Â  Â  Â  // Limpa o target da URL

Â  Â  Â  Â  Â  history.pushState(null, '', window.location.pathname);

Â  Â  Â  Â  Â  autoCallTargetId = null;Â 

Â  Â  Â  } else {

Â  Â  Â  Â  Â  setupCallChannelAndStartAutoCall();

Â  Â  Â  }


Â  Â  } else {

Â  Â  Â  loginModal.style.display = 'flex';

Â  Â  Â  // Limpa o target do URL se nÃ£o estiver logado

Â  Â  Â  history.pushState(null, '', window.location.pathname);

Â  Â  Â  autoCallTargetId = null;

Â  Â  }

Â  });

}


sb.auth.onAuthStateChange((event, session) => {

Â  user = session?.user || null;

Â  if (user && loginModal.style.display === 'flex') {

Â  Â  Â // ForÃ§a a reinicializaÃ§Ã£o se o usuÃ¡rio acabou de entrar.

Â  Â  Â initializeChat();Â 

Â  } else if (!user) {

Â  Â  Â loginModal.style.display = 'flex';

Â  }

});


// inicia quando a pÃ¡gina carrega

// Nota: O initializeChat jÃ¡ lida com a recuperaÃ§Ã£o de sessÃ£o e decide o que fazer.

initializeChat();


// Globaliza funÃ§Ãµes de login/registro

window.login = login; window.register = register; window.reset = reset;

</script>


</body>

</html>



