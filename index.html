

<!DOCTYPE html>

<html lang="pt-BR">

<head>

<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Chat de V√≠deos - Estilo WhatsApp (WebRTC via Supabase)</title>


<script src="¬†https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2¬†"></script>


<style>


/* Estilos baseados no WhatsApp para celular */

:root{ --bg:#e5ddd5; --panel:#fff; --my:#dcf8c6; --accent:#25d366; --header:#075e54; --dark:#111; }

corpo{

margem:0;

fundo:var(--bg);

fam√≠lia-da-fonte: Arial, sem serifa;

altura: 100vh;

altura: 100dvh;

exibi√ß√£o:flex;

flex-direction:column;

overflow:oculto;

}

#topbar{ altura:56px; fundo:var(--header); exibi√ß√£o:flex; alinhamento-itens:centro; preenchimento:0 12px; cor:#fff; tamanho-da-fonte:18px; peso-da-fonte:negrito; justificar-conte√∫do: espa√ßo-entre; posi√ß√£o: relativa; }


/* Garantir que o cont√™iner de mensagens utilize o espa√ßo restante */

#container-de-mensagens{

flex:1;

posi√ß√£o: relativa;

exibi√ß√£o:flex;

flex-direction:column;

}


/* Faz com que a √°rea de mensagens role e use o espa√ßo do container */

#mensagens{

flex:1;

overflow-y:auto;

preenchimento:0 10px 10px 10px;

exibi√ß√£o:flex;

flex-direction:column;

comportamento de rolagem: suave;

cor de fundo:var(--bg);

preenchimento superior: 10px;

tamanho de fundo: capa;

posi√ß√£o de fundo: centro;

}


/* Estilo para o grupo de mensagem e nome do perfil */

.msg-group {

Exibir: flex√≠vel;

flex-direction: coluna;

largura m√°xima: 80%;

margem-inferior: 8px;

}

.¬†msg-group.me¬†{

alinhamento-pr√≥prio: flex-end;

}

.msg-group.other {

alinhamento-pr√≥prio: in√≠cio flex√≠vel;

}


/* Estilo para o nome do perfil (e-mail) */

.nome-do-perfil {

tamanho da fonte: 12px;

cor: #075e54;

margem-inferior: 2px;

alinhamento-pr√≥prio: in√≠cio flex√≠vel;

preenchimento √† esquerda: 8px;

peso da fonte: negrito;

}

.¬†msg-group.me¬†.profile-name {

Cor: #128C7E;

alinhamento-pr√≥prio: flex-end;

preenchimento √† direita: 8px;

preenchimento √† esquerda: 0;

}

.msg{

largura-m√°xima:100%;

preenchimento: 8px 12px;

margem-inferior:2px;

raio-da-borda:8px;

tamanho da fonte: 15px;

altura-da-linha: 1,3;

posi√ß√£o: relativa;

preenchimento √† direita: 50px;

cursor: ponteiro;

}

.me{ align-self:flex-end; background:var(--my);

raio-inferior-direito-da-borda: 0;

}

.other{ align-self:flex-start; background:#fff;

raio-da-borda-inferior-esquerda: 0;

}


/* Estilo do hor√°rio */

.timestamp {

posi√ß√£o: absoluta;

parte inferior: 2px;

direita: 8px;

tamanho da fonte: 10px;

cor: rgba(0, 0, 0, 0.4);

}


/* Garantir rodap√© fixo no celular e considerar barra de gesto */

#inputArea{

altura:60px;

fundo:#fff;

exibi√ß√£o:flex;

alinhar-itens:centro;

preenchimento:0 6px;

espa√ßo:6px;

largura: 100%;

box-sized: caixa com borda;

padding-bottom: env(safe-area-inset-bottom);

}

#textInput{ flex:1; height:40px; border:1px solid #ccc; border-radius:20px; padding:0 14px; font-size:15px; }

.btn{ width:42px; height:42px; border-radius:50%; display:flex; align-items:center; justify-content:center; background:var(--accent); border:none; color:#fff; cursor:pointer;

tamanho da fonte: 18px;

}

.menu-item {

exibir: bloco;

preenchimento: 10px 15px;

decora√ß√£o de texto: nenhuma;

cor: var(--dark);

}

.menu-item:hover {

cor de fundo: #f0f0f0;

}

#√°reaDeChamadaDeV√≠deo{

posi√ß√£o:absoluta; topo:0; esquerda:0; largura:100%; altura:100%;

fundo:rgba(0,0,0,0.9); √≠ndice z:10;

exibir:nenhum; flex-direction: coluna; justify-content:centro; align-items:centro;

}

#V√≠deoLocal{

largura:100%; altura:100%; ajuste do objeto:cobertura;

}

#bot√£odesligue{

posi√ß√£o:absoluta; inferior:20px; fundo:vermelho; cor:branco;

tamanho da fonte: 24px; raio da borda: 30px; preenchimento: 8px 24px; borda: nenhuma; cursor: ponteiro;

}

#loginModal{ position:fixed; top:0; left:0; width:100%; height:100%; background:#fff; z-index:9999; padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center; }

.conte√∫do-do-arquivo {

margem: 4px 0;

}

.file-content img, .file-content video, .file-content audio {

exibir: bloco;

largura m√°xima: 100%;

altura: autom√°tica;

}


/* Estilos para o status de grava√ß√£o de √°udio */

.status-de-grava√ß√£o {

largura: 42px;

altura: 42px;

raio-da-borda: 50%;

fundo: vermelho;

Exibir: flex√≠vel;

alinhamento-itens: centro;

justificar-conte√∫do: centralizado;

anima√ß√£o: pulso 1s infinito alternado;

}

@keyframes pulso {

de { opacidade: 1; }

para { opacidade: 0,5; }

}


</style>


</head>

<body>


<div id="topbar">

<div id="topbar-left"><span id="chatTitle">Chat V√≠deos</span></div>

<button id="kebabBtn">‚ãÆ</button>

<div id="kebabMenu" style="display:none; position:absolute; top:50px; right:5px; background:white; border-radius:4px; box-shadow:0 2px 5px rgba(0,0,0,0.2); min-width:200px; z-index:1000;">

<a href="contacts.html" class="menu-item">üë• Contatos</a>

<a href="#" class="menu-item" onclick="chooseWallpaper()">üñºÔ∏è Trocar Fundo de Tela</a>

<a href="#" class="menu-item" onclick="deleteAllMessages()">üóëÔ∏è Apagar TODAS as Mensagens</a>

<a href="#" class="menu-item" onclick="logout()">Sair</a>

</div>

</div>


<div id="messages-container">

<div id="videoCallArea">

<video id="localVideo" autoplay playsinline muted></video>

<button id="hangupBtn" onclick="hangUpCall()">üìû Desligar</button>

<p style="position:absolute; top:10px; color:white; font-weight:bold;">Videochamada WebRTC</p>

<video id="remoteVideo" autoplay playsinline style="width: 100px; height: 100px; position: absolute; top: 10px; right: 10px; z-index: 100; border-radius: 8px; border: 2px solid white; display:none;"></video>

</div>

<div id="messages"></div>

</div>


<div id="inputArea">

<button id="fileBtn" class="btn">üìé</button>

<input type="file" id="wallpaperInput" accept="image/*" style="display:none">

<input type="file" id="fileInput" accept="video/*,image/*,audio/*" style="display:none">

<button id="videoCallBtn" class="btn" title="Iniciar Videochamada">üìπ</button>

<input id="textInput" placeholder="Mensagem">

<button id="micBtn" class="btn">üé§</button>

<button id="sendBtn" class="btn">‚û§</button>

</div>


<div id="loginModal">

<div style="width:100%;max-width:320px;">

<h2>Entrar</h2>

<input id="email" placeholder="Email (seu nome de perfil)" style="width:100%;padding:10px;margin:6px 0;border-radius:6px;border:1px solid #ccc;">

<input id="pass" placeholder="Senha" type="password" style="width:100%;padding:10px;margin:6px 0;border-radius:6px;border:1px solid #ccc;">

<button onclick="login()">Entrar</button>

<button onclick="register()">Registrar</button>

<button onclick="reset()">Esque√ßa a senha</button>

<p style="font-size:13px;color:#666;margin-top:10px;">Observa√ß√£o: teste em <strong>localhost</strong> ou via <em>HTTPS</em>. Chrome bloqueou c√¢mera/microfone em contexto inseguro.</p>

</div>

</div>


<script>


/* ---------- CONFIGURA√á√ÉO SUPABASE (CHAVE UNIFICADA) ---------- */

const SUPABASE_URL = "¬†https://dktkzsmfhhjxkbhvnwnw.supabase.co¬†";

const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRrdGt6c21maGhqeGtiaHZud253Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NDQ0MTQsImV4cCI6MjA4MDUyMDQxNH0.QpLkvWSaVPdjszXx0_epadmmfMRjwe_8C7WjcQzNbAs";


const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {

autentica√ß√£o: { persistSess√£o: true }

});



/* ---------- Vari√°veis ‚Äã‚ÄãGlobais de Estado e WebRTC ---------- */


seja usu√°rio = nulo;

let localStream = null;

let messagesDiv = document.getElementById('messages');

const loginModal = document.getElementById('loginModal');

const emailInput = document.getElementById('email');

const passInput = document.getElementById('pass');

const textInput = document.getElementById('textInput');

const fileInput = document.getElementById('fileInput');

const wallpaperInput = document.getElementById('wallpaperInput');

const videoCallArea = document.getElementById('videoCallArea');

const localVideo = document.getElementById('localVideo');

const micBtn = document.getElementById('micBtn');

const inputArea = document.getElementById('inputArea');


let peerConnection = null;

let remoteVideo = null;

let callChannel = null;

let autoCallTargetId = null;

let mediaRecorder = null;

let audioChunks = [];



const iceServers = {

Servidores de gelo: [

{ urls: 'stun:stun.l.google.com:19302¬†' },

{ urls: 'stun:¬†stun1.l.google.com:19302¬†' },

{ urls: 'stun:¬†stun2.l.google.com:19302¬†' },

{ urls: 'stun:¬†stun.services.mozilla.com¬†' },

{ urls: 'stun:¬†stun.stunprotocol.org¬†' },

{ urls: 'stun:¬†stun.voipbuster.com¬†' },

{ urls: 'stun:¬†stun.ideasip.com¬†' },

{ urls: 'stun:¬†stun.schlund.de¬†' },

{

URLs: 'turn:¬†openrelay.metered.ca:443?transport=tcp¬†',

nome de usu√°rio: 'openrelayproject',

credencial: 'openrelayproject'

},

{

URLs: 'turn:¬†openrelay.metered.ca:443?transport=udp¬†',

nome de usu√°rio: 'openrelayproject',

credencial: 'openrelayproject'

}

]

};


v√≠deoRemoto = document.getElementById('v√≠deoRemoto');



// Adiciona funcionalidade aos bot√µes

document.getElementById('fileBtn').onclick = () => { if(!user){ alert('Fa√ßa login primeiro'); retornar; } arquivoInput.click(); };


// üö® L√≥gica de INICIAR/PARAR grava√ß√£o no clique do MIC

micBtn.onclick = () => {

if(!user){ alert('Fa√ßa login primeiro'); retornar; }

if(mediaRecorder && mediaRecorder.state === 'gravando') {

pararGrava√ß√£o();

} outro {

iniciarGrava√ß√£o();

}

};


fileInput.onchange = (e) => { if(e.target.files[0]) uploadFile(e.target.files[0]); };

document.getElementById('sendBtn').onclick = sendMessage;

textInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendMessage(); });


document.getElementById('videoCallBtn').onclick = () => {

se(!usu√°rio){

alert('Fa√ßa login para iniciar uma videochamada.');

retornar;

}

let target = autoCallTargetId;

se (!alvo) {

alert("Selecione um contato na lista de 'Contatos' para iniciar uma chamada.");

window.location.href = 'contacts.html';

retornar;

}

iniciarChamadaDeV√≠deo(alvo);

};



document.getElementById('kebabBtn').onclick = () => { const m = document.getElementById('kebabMenu'); m.style.display = m.style.display === 'block' ? 'none' : 'block'; };

document.addEventListener('click', (e)=>{ const m=document.getElementById('kebabMenu'); if(¬†e.target.id¬†!=='kebabBtn' && !m.contains(e.target)) m.style.display='none'; });



/* ---------- FUN√á√ïES AUXILIARES DE VIDEOCHAMADA ---------- */


fun√ß√£o handleTrackEvent(event) {

se (remoteVideo && event.streams && event.streams[0]) {

remoteVideo.srcObject = event.streams[0];

remoteVideo.style.display = 'block';

console.log('Stream remoto recebido.');

}

}


fun√ß√£o ass√≠ncrona handleIceCandidateEvent(event, targetPeerId) {

se (evento.candidato) {

console.log('Enviando candidato ICE:', event.candidate);

await sb.channel('call_room_' + targetPeerId).send({

tipo: 'transmiss√£o',

evento: 'sinal',

carga √∫til: {

senderId:¬†user.id¬†,

targetId: targetPeerId,

tipo: 'candidato a gelo',

candidato: evento.candidato

}

});

}

}


fun√ß√£o ass√≠ncrona handleSignalMessage(payload) {

const signal = payload.payload;

Se (signal.targetId !==¬†user.id¬†) retorne;


console.log('Sinal recebido:', signal.type, signal);


se (signal.type === 'oferta') {

se(conex√£o de pares){

console.log('J√° est√° em chamada. Ignorando nova oferta.');

retornar;

}


if (!confirm(`Chamada recebida de ${signal.senderId.substring(0, 8)}... Deseja atender?`)) {

console.log("Chamada recusada.");

retornar;

}


aguardar inicializarConex√£oPeer(signal.senderId);

aguarde peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));

const resposta = await peerConnection.createAnswer();

aguarde peerConnection.setLocalDescription(resposta);


await sb.channel('call_room_' + signal.senderId).send({

tipo: 'transmiss√£o',

evento: 'sinal',

carga √∫til: {

senderId:¬†user.id¬†,

targetId: signal.senderId,

tipo: 'resposta',

sdp: peerConnection.localDescription

}

});

} else if (signal.type === 'answer') {

aguarde peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));

} else if (signal.type === 'ice-candidate') {

tentar {

if(peerConnection && peerConnection.remoteDescription) {

aguarde peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));

}

} catch (e) {

console.error('Erro ao adicionar candidato ICE:', e);

}

}

}


fun√ß√£o ass√≠ncrona inicializarConex√£oPeer(targetPeerId) {

se (peerConnection) retornar;

tentar {

localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

} catch(err) {

console.error('Erro ao acessar m√≠dia (c√¢mera/microfone):', err);

alert('Erro ao acessar c√¢mera/microfone. Verifique as permiss√µes. ' + (err.message ||¬†err.name¬†));

retornar;

}

peerConnection = new RTCPeerConnection(iceServers);

peerConnection.ontrack = handleTrackEvent;

peerConnection.onicecandidate = (event) => handleIceCandidateEvent(event, targetPeerId);


localVideo.srcObject = localStream;

localVideo.muted = true;

videoCallArea.style.display = 'flex';

localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

remoteVideo.style.display = 'nenhum';

peerConnection.onconnectionstatechange = (event) => {

console.log(`Estado de conex√£o WebRTC: ${peerConnection.connectionState}`);

se (peerConnection.connectionState === 'falhou' || peerConnection.connectionState === 'desconectado') {

console.error("A conex√£o WebRTC falhou ou foi desconectada.");

}

};

}


// üö® FUN√á√ÉO CORRIGIDA PARA LIMPAR O ESTADO EM CASO DE ERRO DE SDP

fun√ß√£o ass√≠ncrona iniciar chamada de v√≠deo(targetPeerId){

if(!user || !targetPeerId){

console.error('Usu√°rio ou alvo n√£o definido.');

retornar;

}


se(!isSecureContext()){

alert('O WebRTC requer HTTPS. Teste em localhost ou por HTTPS.');

retornar;

}


tentar{

// 1. Inicializa a conex√£o (s√≥ executa peerConnection for null)

aguardar inicializarConex√£oPeer(targetPeerId);

if(!peerConnection) return;


// 2. Crie uma Oferta (Proposta de conex√£o)

const offer = await peerConnection.createOffer();

// 3. Defina uma oferta localmente

aguarde peerConnection.setLocalDescription(oferta);

// 4. Envia o sinal para o alvo via Supabase

await sb.channel('call_room_' + targetPeerId).send({

tipo: 'transmiss√£o',

evento: 'sinal',

carga √∫til: {

senderId:¬†user.id¬†,

targetId: targetPeerId,

tipo: 'oferta',

sdp: peerConnection.localDescription

}

});


alert(`Chamada iniciada. Tentando conectar com ${targetPeerId.substring(0, 8)}...`);


}catch(erro){

console.error('Erro ao iniciar WebRTC:', err);

// üö® CORRE√á√ÉO CR√çTICA: For√ßar a limpeza do objeto RTCPeerConnection em caso de erro

// de negocia√ß√£o (como o erro de SDP) para garantir que a pr√≥xima tentativa comece do zero.

hangUpCall();

alert('Erro ao iniciar chamada: ' + (err.message ||¬†err.name¬†));

}

}


fun√ß√£o hangUpCall(){

se(conex√£o de pares){

peerConnection.close();

peerConnection = null;

}

se(localStream){

localStream.getTracks().forEach(t => t.stop());

localStream = nulo;

localVideo.srcObject = null;

}

se(v√≠deoremoto){

remoteVideo.srcObject = null;

remoteVideo.style.display = 'nenhum';

}

videoCallArea.style.display = 'none';

console.log('Chamada encerrada.');

history.pushState(null, '', window.location.pathname);

autoCallTargetId = nulo;

}

janela.desligarChamada = desligarChamada;



/* ---------- GRAVA√á√ÉO E ENVIO DE √ÅUDIO (NOVO) ---------- */


fun√ß√£o ass√≠ncrona iniciarGrava√ß√£o() {

se (!usu√°rio) retornar;


tentar {

const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

mediaRecorder = novo MediaRecorder(stream);

audioChunks = [];

// Exibir indicador de grava√ß√£o (muda o √≠cone do bot√£o)

micBtn.innerHTML = 'üî¥';

micBtn.classList.add('recording-status');

mediaRecorder.ondataavailable = (event) => {

audioChunks.push(event.data);

};


mediaRecorder.onstop = () => {

// Cria o Blob de √°udio e chama a fun√ß√£o de upload

const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

// Reverter o bot√£o

micBtn.innerHTML = 'üé§';

micBtn.classList.remove('recording-status');

// O stream de √°udio pode ser parado

stream.getTracks().forEach(track => track.stop());

// Chama a fun√ß√£o de upload (com o Blob e o prefixo de √°udio)

uploadFile(audioBlob, true);

};


mediaRecorder.start();

textInput.placeholder = 'Gravando √°udio... Clique no microfone para parar.';

console.log('Grava√ß√£o de √°udio iniciada.');


} catch (erro) {

console.error('Erro ao iniciar grava√ß√£o de √°udio:', err);

alert('Erro ao acessar microfone. Verifique as permiss√µes.');

// Reverter o bot√£o

micBtn.innerHTML = 'üé§';

micBtn.classList.remove('recording-status');

}

}


fun√ß√£o pararGrava√ß√£o() {

se (mediaRecorder && mediaRecorder.state === 'gravando') {

mediaRecorder.stop();

textInput.placeholder = 'Mensagem';

}

}



/* ---------- OUTRAS FUN√á√ïES ---------- */


fun√ß√£o escolherPapelDeParede() {

if(!user){ alert('Fa√ßa login primeiro'); retornar; }

wallpaperInput.click();

}

janela.escolherPapelDeParede = escolherPapelDeParede;



wallpaperInput.onchange = (e) => {

const file = e.target.files[0];

se (arquivo) {

const leitor = novo FileReader();

leitor.onload = (e) => {

messagesDiv.style.backgroundImage = `url('${e.target.result}')`;

alert('Fundo de tela alterado!');

};

leitor.lerComoURLDeDados(arquivo);

}

};



fun√ß√£o isSecureContext() {

retornar window.isSecureContext || location.hostname === "localhost" || location.hostname === "127.0.0.1";

}



/* ---------- AUTENTICA√á√ÉO ---------- */


fun√ß√£o ass√≠ncrona login(){

const email = emailInput.value.trim();

const pass = passInput.value;

if(!email || !pass){ alert('Preencha email e senha.'); retornar; }

const { data, error } = await sb.auth.signInWithPassword({ email, password: pass });

if(error){ alert('Erro: ' + (error.message || JSON.stringify(error))); return; }

usu√°rio = dados.usu√°rio;

}



fun√ß√£o ass√≠ncrona register(){

const email = emailInput.value.trim();

const pass = passInput.value;

if(!email.includes('@')){ alert('Email inv√°lido'); return; }

const { data, error } = await sb.auth.signUp({ email, password: pass });

if(error) alert('Erro no registro: ' + (error.message || JSON.stringify(error)));

else alert('Cadastrado! Confirme o email e fa√ßa login.');

}



fun√ß√£o ass√≠ncrona reset(){

const email = emailInput.value.trim();

if(!email.includes('@')){ alert('Email inv√°lido'); return; }

const { data, error } = await sb.auth.resetPasswordForEmail(email);

if(error) alert('Erro: ' + (error.message || JSON.stringify(error)));

else alert('Email de recupera√ß√£o enviado!');

}



fun√ß√£o ass√≠ncrona logout(){

const { error } = await sb.auth.signOut();

if(error) alert('Erro ao sair: ' + error.message);

usu√°rio = nulo;

messagesDiv.innerHTML = '';

loginModal.style.display = 'flex';

document.getElementById('chatTitle').textContent = 'V√≠deos de bate-papo';

messagesDiv.style.backgroundImage = '';

hangUpCall();

history.pushState(null, '', window.location.pathname);

autoCallTargetId = nulo;

}

janela.logout = logout;



/* ---------- EXCLUS√ÉO DE MENSAGENS INDIVIDUAIS ---------- */


janela.abrirMenuDeMensagens = fun√ß√£o(e, msg) {

if(!user || msg.user_id !==¬†user.id¬†) return;

const confirmado = confirm(`Deseja apagar esta mensagem (ID: ${¬†msg.id¬†})?`);

se (confirmado) {

deleteMessage(¬†msg.id¬†);

}

e.stopPropagation();

};



fun√ß√£o ass√≠ncrona excluirMensagem(idMensagem){

se(!usu√°rio) retornar;


const { error } = await sb.from('messages')

.excluir()

.eq('id', messageId)

.eq('user_id',¬†user.id¬†);


se(erro){

alert('Erro ao apagar mensagem: ' + error.message);

console.error(erro);

} outro {

const el = document.querySelector(`[data-message-id="${messageId}"]`);

se(el) {

const groupEl = el.closest('.msg-group');

se(grupoEl) grupoEl.remover();

}

}

}

janela.excluirMensagem = excluirMensagem;



/* ---------- EXCLUS√ÉO EM MASSA DE MENSAGENS ---------- */


fun√ß√£o ass√≠ncrona excluirTodasAsMensagens(){

se(!usu√°rio){

alert('Fa√ßa login primeiro.');

retornar;

}

const confirmado = confirm("‚ö†Ô∏è ATEN√á√ÉO: Deseja REALMENTE apagar TODAS as suas mensagens no chat? Esta a√ß√£o √© irrevers√≠vel.");

se (!confirmado) retornar;

const { error } = await sb.from('messages')

.excluir()

.eq('user_id',¬†user.id¬†);


se(erro){

alert('Erro ao apagar mensagens: ' + error.message);

console.error(erro);

} outro {

messagesDiv.innerHTML = '';

alert('Todas as suas mensagens foram apagadas com sucesso! (Recarregue para garantir a sincroniza√ß√£o em tempo real).');

}

}

janela.excluirTodasAsMensagens = excluirTodasAsMensagens;



/* ---------- RENDER MENSAGENS (CORRIGIDA PARA √ÅUDIO) ---------- */


fun√ß√£o renderMessage(msg){

const date = new Date(msg.created_at);

const timeString = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

const profileName = msg.user_id ===¬†user.id¬†? 'Voc√™' : (msg.email || msg.user_id);

const groupDiv = document.createElement('div');

groupDiv.className = 'msg-group ' + ((user && msg.user_id ===¬†user.id¬†) ? 'me':'other');


const nameSpan = document.createElement('span');

nameSpan.className = 'nome-do-perfil';

nameSpan.textContent = profileName;

groupDiv.appendChild(nameSpan);


const div = document.createElement('div');

div.className = 'msg ' + ((user && msg.user_id ===¬†user.id¬†) ? 'me':'other');

div.dataset.messageId =¬†msg.id¬†;

div.onclick = (e) => openMessageMenu(e, msg);


let content = msg.text || '';

const prefixes = { '[√Åudio]:':'audio', '[Imagem]:':'image', '[V√≠deo]:':'video', '[Arquivo]:':'file' };

para(const p em prefixos){

if(content.startsWith(p)){

const type = prefixes[p];

const path = content.substring(p.length).trim();

//Obter URL p√∫blica do Bucket 'messages'

const { data: urlData } = sb.storage.from('messages').getPublicUrl(path);

const fileUrl = urlData.publicUrl;

se (tipo === 'imagem') {

conte√∫do = `<div class="file-content">üñºÔ∏è <a href="${fileUrl}" target="_blank"><img src="${fileUrl}" alt="imagem" style="max-width:220px;border-radius:6px"></a></div>`;

} sen√£o se(tipo === 'v√≠deo') {

content = `<div class="file-content"> üìπ<video controles style="max-width:240px;border-radius:6px"><source src="${fileUrl}">Seu navegador n√£o suporta.</video></div>`;

} sen√£o se(tipo === '√°udio') {

// Renderiza o reprodutor de √°udio

conte√∫do = `<div class="file-content">üé§<audio controls src="${fileUrl}" style="max-width:240px"></audio></div>`;

} outro {

const fileName = path.split('/').pop();

conte√∫do = `<div class="file-content">üì¶ <a href="${fileUrl}" target="_blank" download>${fileName}></div>`;

}

quebrar;

}

}


div.innerHTML = `${content}<span class="timestamp">${timeString}</span>`;

groupDiv.appendChild(div);

messagesDiv.appendChild(groupDiv);

messagesDiv.scrollTop = messagesDiv.scrollHeight;

}



/* ---------- INSERIR E CARREGAR HIST√ìRICO ---------- */


fun√ß√£o ass√≠ncrona enviarMensagem(){

const text = textInput.value.trim();

if(!text || !user) return;

const { error } = await sb.from('messages').insert({ user_id:¬†user.id¬†, text, email: user.email });

if(error) alert('Erro ao enviar: ' + error.message);

caso contr√°rio, textInput.value = '';

}



fun√ß√£o ass√≠ncrona carregarHist√≥rico(){

const { data, error } = await sb.from('messages').select('*').order('created_at', { ascending: true });

if(erro){ console.erro(erro); alert('Erro ao carregar hist√≥rico'); retornar; }

messagesDiv.innerHTML = '';

dados.forEach(renderMessage);

}



/* ---------- SUBSCRIBE (Realtime Otimizado) ---------- */


fun√ß√£o subscribeToMessages(){

se(janela.chatChannel) {

sb.removeChannel(window.chatChannel);

console.log('Canal Realtime anterior removido.');

}

window.chatChannel = sb.channel('public:messages')

.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {

if(payload &&¬†payload.new¬†) renderMessage(¬†payload.new¬†);

})

.subscribe((status) => {

se (status === 'ASSINADO') {

console.log('Mensagens em tempo real: INSCRITO');

}

});

}



/* ---------- UPLOAD (CORRIGIDO PARA O BUCKET 'mensagens' e √ÅUDIO) ---------- */


fun√ß√£o ass√≠ncrona uploadFile(arquivo, isAudio = false){

if(!file || !user) return;

let mimeType = file.type || '';

if(isAudio) mimeType = 'audio/webm';


let prefix = '[Arquivo]: ';

if(isAudio) prefix = '[√Åudio]: ';

sen√£o se(mimeType.startsWith('video/')) prefixo = '[V√≠deo]: ';

sen√£o se(mimeType.startsWith('image/')) prefixo = '[Imagem]: ';

const fileExtension = isAudio? 'webm': (file.name.split('.').pop() || 'dat');

const safeName = file.name.replace(/[^a-z0-9.]/gi, '_').toLowerCase() || 'audio';

const path = `${¬†user.id¬†}/${Date.now()}_${safeName}.${fileExtension}`;

// Usa o Bucket CORRETO 'messages'

const { data: uploadData, error: uploadError } = await sb.storage

.from('mensagens')

.upload(caminho, arquivo, {

cacheControl: '3600',

upsert: falso,

contentType: mimeType

});

se(uploadError){

console.error(uploadError);

alert('Erro no upload: ' + uploadError.message);

retornar;

}

const { error: dbError } = await sb.from('messages').insert({ user_id:¬†user.id¬†, text: `${prefix}${uploadData.path}`, email: user.email });

if(dbError) alert('Erro ao gravar mensagem: ' + dbError.message);

// Limpar o arquivo de entrada apenas se n√£o for um Blob de √°udio

if(!isAudio) fileInput.value = '';

}



// Fun√ß√£o para obter par√¢metros da URL

fun√ß√£o obterPar√¢metroUrl(nome) {

nome = nome.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');

const regex = new RegExp('[\\?&]' + nome + '=([^&#]*)');

const results = regex.exec(location.search);

return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));

};



/* ---------- FUN√á√ÉO DE NOTIFICA√á√ÉO PUSH ---------- */


fun√ß√£o urlBase64ToUint8Array(base64String) {

const padding = '='.repeat((4 - base64String.length % 4) % 4);

const base64 = (base64String + preenchimento)

.replace(/-/g, '+')

.replace(/_/g, '/');


const rawData = janela.atob(base64);

const outputArray = new Uint8Array(rawData.length);


para (let i = 0; i < rawData.length; ++i) {

outputArray[i] = rawData.charCodeAt(i);

}

retornar arrayDeSa√≠da;

}



fun√ß√£o ass√≠ncrona subscribeUserToPush() {

const PUBLIC_VAPID_KEY = 'BMaR3zFqEh_OVdJSDBEWokPLjYg0LxausOc9VrQj_FKwW869k7rK07M_bLbrE3WoVYkA0tkK-DwssC4K2I9BJ2U';


if (!('serviceWorker' in navigator) || !('PushManager' in window) || !user) {

console.warn('Push n√£o suportado ou usu√°rio n√£o logado.');

retornar;

}


console.log(`‚û°Ô∏è Status da permiss√£o de notifica√ß√£o atual: ${Notification.permission}`);


tentar {

const swReg = await navigator.serviceWorker.register('service-worker.js');

console.log('‚úÖ Service Worker registrado com sucesso!');


se (Notifica√ß√£o.permiss√£o === 'padr√£o') {

const permissionResult = await Notification.requestPermission();

console.log(`Novo status de permiss√£o: ${permissionResult}`);

se (permiss√£oResultado !== 'concedida') {

console.log('üõë Permiss√£o negada pelo usu√°rio.');

retornar;

}

} else if (Notification.permission === 'denied') {

console.log('üõë Permiss√£o negada anteriormente. O usu√°rio deve reiniciar manualmente.');

retornar;

}


const applicationServerKey = urlBase64ToUint8Array(PUBLIC_VAPID_KEY);

const subscription = await swReg.pushManager.subscribe({

userVisibleOnly: true,

applicationServerKey: applicationServerKey

});


console.log('‚úÖ Objeto de assinatura Push criado (Token gerado):', subscription);


const { error: dbError } = await sb.from('user_subscriptions').upsert({

user_id:¬†user.id¬†,

dados_de_assinatura: assinatura,

atualizado_em: novo Date().toISOString()

}, { onConflict: 'user_id' });


se (dbError) {

console.error('üõë Falha ao salvar inscri√ß√£o Push no Supabase:', dbError);

alert('Erro: ' + dbError.message);

} outro {

console.log('‚úÖ Inscri√ß√£o Push salva com sucesso no Supabase!');

}


} catch (erro) {

console.error('Falha na inscri√ß√£o Push. Detalhes:', err);

se (¬†err.name¬†=== 'NotAllowedError') {

alert('Notifica√ß√µes bloqueadas. Habilitar configura√ß√µes do navegador.');

} outro {

alert('Erro ao registrar Push: ' + err.message);

}

}

}



/* ---------- L√≥gica de assinatura e in√≠cio de chamada autom√°tica ---------- */


fun√ß√£o setupCallChannelAndStartAutoCall() {

se (!usu√°rio) retornar;

se (!callChannel) {

callChannel = sb.channel('call_room_' +¬†user.id¬†);

callChannel.on('broadcast', { event: 'signal' }, handleSignalMessage).subscribe((status) => {

se (status === 'ASSINADO') {

console.log(`Pronto para receber chamadas no canal: call_room_${¬†user.id¬†}`);

se (autoCallTargetId && autoCallTargetId !==¬†user.id¬†) {

iniciarChamadaDeV√≠deo(autoCallTargetId);

}

}

});

} outro {

se (autoCallTargetId && autoCallTargetId !==¬†user.id¬†) {

iniciarChamadaDeV√≠deo(autoCallTargetId);

}

}

}



/* ---------- INICIALIZA√á√ÉO ---------- */


fun√ß√£o initializeChat(event_type = 'SESSION_RECOVERED'){

autoCallTargetId = getUrlParameter('target');

se(usu√°rio){

loginModal.style.display = 'nenhum';

document.getElementById('chatTitle').textContent = user.email.split('@')[0];

carregarHist√≥rico();

subscribeToMessages();

if(event_type !== 'SIGNED_IN') {

subscribeUserToPush();

}


se (autoCallTargetId ===¬†user.id¬†) {

alert("Voc√™ n√£o pode ligar para si mesmo.");

history.pushState(null, '', window.location.pathname);

autoCallTargetId = nulo;

} outro {

setupCallChannelAndStartAutoCall();

}


} outro {

loginModal.style.display = 'flex';

history.pushState(null, '', window.location.pathname);

autoCallTargetId = nulo;

}

}


sb.auth.onAuthStateChange(async (event, session) => {

usu√°rio = sess√£o?.usu√°rio || nulo;

se (usu√°rio) {

se (evento === 'SIGNED_IN') {

alert('Bem-vindo! Para receber alertas de chamadas e mensagens quando o aplicativo n√£o estiver aberto, clique em "Permitir" na pr√≥xima notifica√ß√£o.');

inicializarChat('ENTRADO');

aguardar subscribeUserToPush();

} else if (event === 'INITIAL_SESSION' || event === 'TOKEN_REFRESHED' || event === 'USER_UPDATED') {

inicializarChat('SESS√ÉO_RECOVERED');

}

} else if (event === 'SIGNED_OUT') {

loginModal.style.display = 'flex';

}

});



sb.auth.getSession().then(({ data: { session } }) => {

se(!sess√£o) {

inicializarChat('SEM_SESS√ÉO');

}

});


janela.login = login; janela.register = registrar; janela.reset = redefinir;


</script>



</body>

</html>



