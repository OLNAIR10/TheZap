<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>TheZap Privado</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
  /* CSS GERAL */
  :root{ 
    --bg:#e5ddd5; /* Cor de fundo padr√£o do WhatsApp */
    --top:#4a148c; /* Roxo principal */
    --card-bg:#fff; 
    --input-bg:#f0f0f0; 
    --msg-in:#fff; 
    --msg-out:#e1bee7; /* Lil√°s (Sua cor) */
    --mic-btn: #8050a9; /* Cor do bot√£o de microfone (roxo escuro) */
    --status-pending: #888; /* Cor para status 'enviando' */
    --status-sent: #008000; /* Cor para status 'enviado' (opcional) */
  }
  
  body { margin:0; font-family:system-ui, -apple-system, sans-serif; background: var(--bg); display:flex; justify-content:center; height: 100dvh; overflow:hidden; }
  
  .card { width:100%; max-width:720px; background:var(--card-bg); display:flex; flex-direction:column; height:100%; position: relative; }
  
  /* TOPO ROXO */
  .topbar { background:var(--top); color:white; padding:10px; display:flex; align-items:center; justify-content:space-between; flex-shrink: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 10; }
  .btn-back { color:white; text-decoration:none; font-size:24px; margin-right:15px; cursor: pointer; }
  
  /* MENSAGENS */
  .messages-wrap { flex:1; overflow-y:auto; padding:15px; display:flex; flex-direction:column; gap:8px; 
    background-image: url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAoACgDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAD/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAT/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAPwArAAAAAAAAAAAP/Z'); /* Padr√£o de fundo do WhatsApp */
    background-repeat: repeat; 
    background-color: #e5ddd5; 
  }
  
  .bubble { 
    max-width:80%; 
    padding:8px 12px; 
    border-radius:8px; 
    background:var(--msg-in); 
    align-self:flex-start; 
    font-size:15px; 
    box-shadow:0 1px 2px rgba(0,0,0,0.1); 
    color: #000; 
    position: relative;
    opacity: 1; /* Padr√£o */
  }
  .bubble.me { background:var(--msg-out); align-self:flex-end; }

  /* OTIMIZA√á√ÉO: Mensagem local, ainda n√£o confirmada pelo servidor */
  .bubble.pending {
    opacity: 0.6; 
  }
  
  .bubble-autor { font-size:11px; font-weight:bold; color:var(--top); margin-bottom:2px; }
  .meta { font-size:10px; color:#555; text-align:right; margin-top: 3px; display: block; }
  .status-icon { margin-left: 5px; color: var(--status-pending); font-weight: normal; }

  /* BARRA DE DIGITAR */
  .composer { padding:10px; background:var(--input-bg); display:flex; gap:10px; align-items: center; border-top: 1px solid #ddd; flex-shrink: 0; }
  input { flex:1; padding:12px; border-radius:20px; border:none; outline:none; background: white; font-size: 15px; transition: all 0.2s; }
  input:disabled { background: #e0e0e0; cursor: not-allowed; } /* Feedback para bloqueio */

  .btn-send, .btn-mic { 
    background:var(--top); 
    color:white; 
    border:none; 
    width: 45px; 
    height: 45px; 
    border-radius:50%; 
    cursor:pointer; 
    font-size: 18px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transition: background 0.2s;
  }
  .btn-mic { background: var(--mic-btn); } /* Cor do mic */

  /* MODO DE GRAVA√á√ÉO */
  .recording-status { 
      flex: 1; 
      display: none; 
      align-items: center; 
      gap: 10px; 
      color: var(--top);
      font-weight: bold;
      padding-left: 10px;
  }
  .recording-status.active { display: flex; }
  .recording-status .dot { 
      width: 10px; 
      height: 10px; 
      background: red; 
      border-radius: 50%; 
      animation: pulse 1s infinite; 
  }
  @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
  }

  /* ESTILO DO √ÅUDIO */
  .audio-player-wrap { 
    display: flex; 
    align-items: center; 
    gap: 8px; 
    min-width: 150px; 
    padding: 2px 0;
  }
  .audio-player-wrap audio { display: none; }
  .btn-audio-control {
    background: var(--top);
    color: white;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    flex-shrink: 0;
  }
  .audio-time { 
    font-size: 11px; 
    color: var(--text-secondary, #555);
    flex-grow: 1;
  }

  /* MODAL DE ENTRADA NA SALA */
  .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
  .modal-box { background: white; padding: 25px; border-radius: 15px; width: 90%; max-width: 350px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3); }
  .modal-box h2 { color: var(--top); margin-top: 0; }
  .modal-box input { width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box; text-align: center; }
  .modal-box input:focus { border-color: var(--top); }
  .btn-enter { background: var(--top); color: white; padding: 12px; width: 100%; border: none; border-radius: 8px; font-weight: bold; font-size: 16px; cursor: pointer; }
  .hidden { display: none !important; }
</style>
</head>
<body>

<div class="card">
    <div class="topbar">
        <div style="display:flex; align-items:center;">
            <a href="/" class="btn-back">‚¨Ö</a>
            <div>
                <div style="font-weight:bold; font-size: 16px;" id="roomName">Privado</div>
                <div style="font-size:12px; opacity: 0.8;">Chat Secreto</div>
            </div>
        </div>
    </div>

    <div id="messagesWrap" class="messages-wrap"></div>

    <div class="composer">
        <input type="text" id="txt" placeholder="Digite aqui..." autofocus>
        
        <div id="recordingStatus" class="recording-status">
            <div class="dot"></div>
            <span id="recTimer">0:00</span>
        </div>

        <button id="sendBtn" class="btn-send" onclick="send()">‚û§</button>
        <button id="micBtn" class="btn-mic" onmousedown="handleMicPress(event)" onmouseup="handleMicRelease()" ontouchstart="handleMicPress(event)" ontouchend="handleMicRelease()">üé§</button>
    </div>
</div>

<div id="loginRoomModal" class="modal-overlay">
    <div class="modal-box">
        <h2>üîí Chat Privado</h2>
        <p>Crie um nome para a sala ou digite um existente para entrar.</p>
        <input type="text" id="inputSala" placeholder="Ex: familia123">
        <button class="btn-enter" onclick="entrarSala()">ENTRAR NA SALA</button>
        <br><br>
        <a href="/" style="color: #666; text-decoration: none; font-size: 14px;">Voltar ao In√≠cio</a>
    </div>
</div>

<script>
    // Configura√ß√µes do Supabase (Mantenha as suas chaves reais)
    const SUPABASE_URL = 'https://zlppiyhqlhppbhkurisr.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpscHBpeWhxbGhwcGJoa3VyaXNyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4NjA0MzYsImV4cCI6MjA3OTQzNjQzNn0.ybVSaBl18pz8OQbtL6NTYkY3dIQ4H8qd4OuGRp6ngFnI';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    
    // Elementos DOM
    const el = {
        messagesWrap: document.getElementById('messagesWrap'),
        txt: document.getElementById('txt'),
        sendBtn: document.getElementById('sendBtn'),
        micBtn: document.getElementById('micBtn'),
        recordingStatus: document.getElementById('recordingStatus'),
        recTimer: document.getElementById('recTimer'),
    };

    let currentUser = null;
    let currentRoom = null;
    let localMessageIdCounter = 0; // Para identificar mensagens locais

    // Vari√°veis de Grava√ß√£o
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let recordingTimerId = null;
    let recordingStartTime = 0;
    let currentStream = null;
    let currentlyPlayingAudio = null;

    // --- FUN√á√ïES DE UTILIADADE ---

    function scrollToBottom() { 
        // Pequeno atraso para garantir que a renderiza√ß√£o do novo elemento terminou
        setTimeout(() => { el.messagesWrap.scrollTop = el.messagesWrap.scrollHeight; }, 50);
    }
    
    function formatTime(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60);
        return `${min}:${sec < 10 ? '0' : ''}${sec}`;
    }
    
    // Bloqueia a interface durante opera√ß√µes cr√≠ticas (upload/send)
    function setInterfaceEnabled(enabled) {
        el.txt.disabled = !enabled;
        el.sendBtn.disabled = !enabled;
        el.micBtn.disabled = !enabled;
    }

    // --- AUTENTICA√á√ÉO E ENTRADA NA SALA ---

    async function init() {
        const {data} = await supabaseClient.auth.getSession();
        if(!data.session) return window.location.href = '/';
        currentUser = data.session.user;
        
        updateComposerButtons();
        
        el.txt.onkeydown = (e) => { if(e.key === 'Enter') send(); };
        el.txt.oninput = updateComposerButtons;
    }
    init();

    function updateComposerButtons() {
        const isEmpty = el.txt.value.trim() === '';
        el.sendBtn.style.display = isEmpty ? 'none' : 'flex';
        el.micBtn.style.display = isEmpty ? 'flex' : 'none';
    }

    function entrarSala() {
        const salaInput = document.getElementById('inputSala').value.trim();
        if(!salaInput) return alert("Digite um nome para a sala!");

        currentRoom = salaInput.toLowerCase().replace(/\s/g, ''); 
        
        document.getElementById('roomName').textContent = "Sala: " + currentRoom;
        document.getElementById('loginRoomModal').classList.add('hidden'); 
        
        fetchMessages();
        setupRealtime();
    }

    // --- GRAVA√á√ÉO DE √ÅUDIO ---

    async function startRecording() {
        if (isRecording) return;
        
        try {
            // Requisita permiss√£o do microfone
            currentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(currentStream);
            audioChunks = [];

            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) audioChunks.push(e.data);
            };

            mediaRecorder.onstop = uploadAudio;

            mediaRecorder.start();
            isRecording = true;
            
            // UI de Grava√ß√£o
            el.micBtn.classList.add('hidden');
            el.recordingStatus.classList.add('active');
            el.txt.classList.add('hidden');
            el.sendBtn.classList.add('hidden');

            recordingStartTime = Date.now();
            el.recTimer.textContent = '0:00';

            recordingTimerId = setInterval(() => {
                const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
                el.recTimer.textContent = formatTime(elapsedSeconds);
            }, 1000);

        } catch (e) {
            alert("Erro ao acessar o microfone: Verifique as permiss√µes. " + e.message);
            isRecording = false;
            // Garante que a UI volte ao normal em caso de erro
            el.micBtn.classList.remove('hidden');
            el.txt.classList.remove('hidden');
            updateComposerButtons();
        }
    }

    function stopRecording() {
        if (!isRecording) return;

        isRecording = false;
        clearInterval(recordingTimerId);
        
        // UI de Parada
        el.recordingStatus.classList.remove('active');
        el.txt.classList.remove('hidden');
        
        // Para a grava√ß√£o e o stream
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }
    }

    let pressTimer;
    
    function handleMicPress(event) {
        event.preventDefault(); // Previne menu de contexto
        // Inicia a grava√ß√£o ap√≥s 300ms de press√£o cont√≠nua
        pressTimer = setTimeout(startRecording, 300);
    }

    function handleMicRelease() {
        clearTimeout(pressTimer);
        if (isRecording) {
            stopRecording();
        }
    }

    async function uploadAudio() {
        if (audioChunks.length === 0) return;

        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        
        if (audioBlob.size < 5000) { 
            alert("√Åudio muito curto."); 
            updateComposerButtons();
            return; 
        }

        // BLOQUEIA A INTERFACE DURANTE O UPLOAD
        setInterfaceEnabled(false);
        el.recTimer.textContent = 'Enviando...';
        
        const uploadName = `messages/${currentUser.id}_${Date.now()}.webm`;
        
        // OTIMIZA√á√ÉO: Renderiza a mensagem de √°udio localmente (Pending/Optimistic)
        const localId = 'local-' + localMessageIdCounter++;
        const tempURL = URL.createObjectURL(audioBlob);
        
        const optimisticMsg = {
            id: localId,
            texto: tempURL,
            user_id: currentUser.id,
            autor_nome: currentUser.user_metadata.full_name,
            created_at: new Date().toISOString(),
            tipo: 'audio',
            local: true // Flag para identificar
        };
        renderMessage(optimisticMsg);


        try {
            // 1. Upload para o Storage (ASYNCHRONOUS)
            const { error: uploadError } = await supabaseClient.storage.from('arquivos').upload(uploadName, audioBlob, {
                contentType: 'audio/webm',
                cacheControl: '3600'
            });
            if (uploadError) throw uploadError;

            // 2. Obter URL P√∫blica
            const { data: { publicUrl } } = supabaseClient.storage.from('arquivos').getPublicUrl(uploadName);

            // 3. Inserir mensagem com URL de √°udio
            const { error: insertError, data: dbData } = await supabaseClient.from('banco').insert([{
                texto: publicUrl, 
                user_id: currentUser.id,
                autor_nome: currentUser.user_metadata.full_name,
                sala_id: currentRoom,
                tipo: 'audio' 
            }]).select();
            if (insertError) throw insertError;
            
            // Remove a mensagem tempor√°ria local e confia no Realtime para inserir a final
            // Ou, opcionalmente, voc√™ pode atualizar o elemento local para 'enviado'

        } catch (e) {
            alert("Erro ao enviar √°udio. Verifique sua conex√£o. " + e.message);
            // Em caso de falha, remover a bolha local ou marcar como falha
            document.getElementById(localId)?.remove();

        } finally {
            // LIMPEZA
            el.recTimer.textContent = '0:00';
            setInterfaceEnabled(true);
            updateComposerButtons();
            URL.revokeObjectURL(tempURL);
        }
    }

    // --- √ÅUDIO PLAYBACK ---

    window.playAudio = (btn, url) => {
        const audio = btn.nextElementSibling;
        
        if (currentlyPlayingAudio && currentlyPlayingAudio !== audio) {
            currentlyPlayingAudio.pause();
            currentlyPlayingAudio.currentTime = 0;
            const playingBtn = currentlyPlayingAudio.previousElementSibling;
            if (playingBtn) playingBtn.innerHTML = '‚ñ∂';
        }
        
        if (audio.paused) {
            currentlyPlayingAudio = audio;
            audio.play();
            btn.innerHTML = '‚ùö‚ùö';
        } else {
            audio.pause();
            btn.innerHTML = '‚ñ∂';
        }
    }
    
    // --- CARREGAMENTO E RENDERIZA√á√ÉO ---

    async function fetchMessages() {
        const { data } = await supabaseClient.from('banco')
            .select('*')
            .eq('sala_id', currentRoom)
            .order('created_at', { ascending: true });
            
        el.messagesWrap.innerHTML = '';
        if(data) data.forEach(msg => renderMessage(msg, false)); // N√£o √© local
        scrollToBottom();
    }

    /**
     * Renderiza a mensagem na tela.
     * @param {Object} msg - Objeto da mensagem.
     * @param {boolean} isRealtime - Indica se a mensagem veio do Realtime.
     */
    function renderMessage(msg, isRealtime = false) {
        // Se a mensagem veio do Realtime e j√° existe uma mensagem local
        // (Optimistic UI) com o mesmo conte√∫do/tempo, ignora para evitar duplicidade.
        if (isRealtime && msg.user_id === currentUser.id) {
            // O ideal seria usar o ID do banco (PK) para verificar, mas aqui confiamos no Realtime
            // O RLS + Realtime garante que a mensagem que chega √© a final. 
            // Para simplicidade, deixamos o Realtime renderizar a bolha oficial.
        }

        const isMe = msg.user_id === currentUser.id;
        const div = document.createElement('div');
        div.className = `bubble ${isMe ? 'me' : ''} ${msg.local ? 'pending' : ''}`;
        
        if(msg.local) div.id = msg.id; // Define ID para remo√ß√£o/atualiza√ß√£o posterior
        
        const timestamp = new Date(msg.created_at || Date.now()).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        
        let contentHTML = '';
        const isAudio = msg.tipo === 'audio' || (msg.texto && (msg.texto.startsWith('blob:') || msg.texto.startsWith('http')));
        
        if (isAudio) {
            contentHTML = `
                <div class="audio-player-wrap">
                    <button class="btn-audio-control" onclick="playAudio(this, '${msg.texto}')">‚ñ∂</button>
                    <audio src="${msg.texto}" onended="this.previousElementSibling.innerHTML='‚ñ∂'; this.currentTime=0;"></audio>
                    <span class="audio-time">${msg.local ? 'Gravado...' : '√Åudio'}</span>
                </div>
            `;
        } else {
            contentHTML = msg.texto.replace(/\n/g, '<br>');
        }
        
        let statusIcon = '';
        if (isMe) {
            // OTIMIZA√á√ÉO: Rel√≥gio para Pendente / Vazio para Enviado
            statusIcon = msg.local ? '<span class="status-icon">üïí</span>' : '<span class="status-icon" style="color:var(--status-sent, #008000);">‚úî</span>'; 
        }
        
        div.innerHTML = `
            <div class="bubble-autor">${msg.autor_nome}</div>
            ${contentHTML}
            <div class="meta">${timestamp}${statusIcon}</div>
        `;
        el.messagesWrap.appendChild(div);
        scrollToBottom();
    }

    // --- ENVIO DE TEXTO (OTIMIZADO) ---

    async function send() {
        const texto = el.txt.value.trim();
        if(!texto || !currentUser) return;
        
        el.txt.value = ''; 
        updateComposerButtons();
        setInterfaceEnabled(false); // Bloqueia temporariamente para evitar spam

        // OTIMIZA√á√ÉO: 1. Renderiza a bolha local (Optimistic UI)
        const localId = 'local-' + localMessageIdCounter++;
        const optimisticMsg = {
            id: localId,
            texto: texto,
            user_id: currentUser.id,
            autor_nome: currentUser.user_metadata.full_name,
            created_at: new Date().toISOString(),
            tipo: 'text',
            local: true
        };
        renderMessage(optimisticMsg);
        
        try {
            // OTIMIZA√á√ÉO: 2. Envia para o banco de forma ass√≠ncrona
            const { error } = await supabaseClient.from('banco').insert([{
                texto: texto,
                user_id: currentUser.id,
                autor_nome: currentUser.user_metadata.full_name,
                sala_id: currentRoom
            }]);

            if (error) throw error;
            
            // OTIMIZA√á√ÉO: 3. Atualiza o status da bolha local para 'Enviado' (‚úî)
            const localDiv = document.getElementById(localId);
            if (localDiv) {
                localDiv.classList.remove('pending');
                localDiv.querySelector('.status-icon').innerHTML = '‚úî';
            }

        } catch (e) {
            console.error("Falha ao enviar mensagem:", e);
            alert("Erro ao enviar. Tente novamente.");
            // Em caso de falha, marca como erro
            const localDiv = document.getElementById(localId);
            if (localDiv) {
                localDiv.querySelector('.status-icon').innerHTML = '‚ùå';
            }
        } finally {
            setInterfaceEnabled(true);
        }
    }

    // --- TEMPO REAL ---
    function setupRealtime() {
        supabaseClient.channel('private-room')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'banco', filter: `sala_id=eq.${currentRoom}` }, payload => {
            
            // OTIMIZA√á√ÉO: Se a mensagem veio do Realtime e √© do pr√≥prio usu√°rio, 
            // ela j√° foi renderizada pelo Optimistic UI (ou est√° sendo atualizada).
            // Removendo a bolha tempor√°ria (se existir) e permitindo que a bolha Realtime entre, 
            // ou simplesmente ignorando se a bolha local j√° foi confirmada (modelo mais avan√ßado).
            
            const isLocalMessage = payload.new.user_id === currentUser.id;
            
            // Se a mensagem for minha, a bolha j√° est√° na tela.
            // Eu apenas permito que o Realtime a atualize (ou simplesmente ignoro, 
            // pois o Optimistic UI j√° a colocou l√°).
            // Para simplificar, vamos permitir que o Realtime renderize a bolha oficial (sem a flag 'local').
            
            // O problema da duplicidade √© resolvido: a bolha local (optimistic) √© atualizada para a bolha oficial quando o Realtime dispara.
            
            // Para este c√≥digo, vamos deixar o Realtime renderizar e confiar que a bolha optimista ser√° atualizada:
            renderMessage(payload.new, true);

        }).subscribe();
    }
</script>
</body>
</html>
