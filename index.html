<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<title>Chat de V√≠deos - WhatsApp Style (WebRTC via Supabase)</title>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<style>

/* Estilos baseados no WhatsApp para mobile */
:root{ --bg:#e5ddd5; --panel:#fff; --my:#dcf8c6; --accent:#25d366; --header:#075e54; --dark:#111; }
body{ 
    margin:0; 
    background:var(--bg); 
    font-family:Arial, sans-serif; 
    height: 100vh;
    height: 100dvh; 
    display:flex; 
    flex-direction:column; 
    overflow:hidden; 
}
#topbar{ height:56px; background:var(--header); display:flex; align-items:center; padding:0 12px; color:#fff; font-size:18px; font-weight:bold; justify-content: space-between; position: relative; }

/* Garante que o container de mensagens use o espa√ßo restante */
#messages-container{ 
    flex:1; 
    position: relative; 
    display:flex; 
    flex-direction:column;
}

/* Faz com que a √°rea de mensagens role e use o espa√ßo do container */
#messages{ 
    flex:1; 
    overflow-y:auto; 
    padding:0 10px 10px 10px; 
    display:flex; 
    flex-direction:column; 
    scroll-behavior:smooth; 
    background-color:var(--bg); 
    padding-top: 10px;
    background-size: cover; 
    background-position: center; 
}

/* Estilo para o grupo de mensagem e nome do perfil */
.msg-group {
    display: flex;
    flex-direction: column;
    max-width: 80%;
    margin-bottom: 8px; 
}
.msg-group.me {
    align-self: flex-end;
}
.msg-group.other {
    align-self: flex-start;
}

/* Estilo para o nome do perfil (e-mail) */
.profile-name {
    font-size: 12px;
    color: #075e54; 
    margin-bottom: 2px;
    align-self: flex-start;
    padding-left: 8px;
    font-weight: bold;
}
.msg-group.me .profile-name {
    color: #128C7E;
    align-self: flex-end;
    padding-right: 8px;
    padding-left: 0;
}
.msg{ 
    max-width:100%; 
    padding:8px 12px; 
    margin-bottom:2px; 
    border-radius:8px; 
    font-size:15px; 
    line-height:1.3; 
    position: relative;
    padding-right: 50px; 
    cursor: pointer; 
}
.me{ align-self:flex-end; background:var(--my); 
    border-bottom-right-radius: 0; 
}
.other{ align-self:flex-start; background:#fff; 
    border-bottom-left-radius: 0; 
}

/* Estilo do hor√°rio */
.timestamp {
    position: absolute;
    bottom: 2px;
    right: 8px;
    font-size: 10px;
    color: rgba(0, 0, 0, 0.4);
}

/* Garante rodap√© fixo no mobile e considera barra de gesto */
#inputArea{ 
    height:60px; 
    background:#fff; 
    display:flex; 
    align-items:center; 
    padding:0 6px; 
    gap:6px; 
    width: 100%;
    box-sizing: border-box; 
    padding-bottom: env(safe-area-inset-bottom); 
}
#textInput{ flex:1; height:40px; border:1px solid #ccc; border-radius:20px; padding:0 14px; font-size:15px; }
.btn{ width:42px; height:42px; border-radius:50%; display:flex; align-items:center; justify-content:center; background:var(--accent); border:none; color:#fff; cursor:pointer; 
    font-size: 18px; 
}
.menu-item {
    display: block;
    padding: 10px 15px;
    text-decoration: none;
    color: var(--dark);
}
.menu-item:hover {
    background-color: #f0f0f0;
}
#videoCallArea{ 
    position:absolute; top:0; left:0; width:100%; height:100%; 
    background:rgba(0,0,0,0.9); z-index:10; 
    display:none; flex-direction: column; justify-content:center; align-items:center; 
}
#localVideo{ 
    width:100%; height:100%; object-fit:cover; 
}
#hangupBtn{ 
    position:absolute; bottom:20px; background:red; color:white; 
    font-size:24px; border-radius:30px; padding:8px 24px; border:none; cursor:pointer; 
}
#loginModal{ position:fixed; top:0; left:0; width:100%; height:100%; background:#fff; z-index:9999; padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center; }
.file-content {
    margin: 4px 0;
}
.file-content img, .file-content video, .file-content audio {
    display: block;
    max-width: 100%; 
    height: auto;
}

/* Estilos para o status de grava√ß√£o de √°udio */
.recording-status {
    width: 42px; 
    height: 42px;
    border-radius: 50%;
    background: red;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: pulse 1s infinite alternate;
}
@keyframes pulse {
    from { opacity: 1; }
    to { opacity: 0.5; }
}

</style>

</head>
<body>

<div id="topbar">
    <div id="topbar-left"><span id="chatTitle">Chat V√≠deos</span></div>
    <button id="kebabBtn">‚ãÆ</button>
    <div id="kebabMenu" style="display:none; position:absolute; top:50px; right:5px; background:white; border-radius:4px; box-shadow:0 2px 5px rgba(0,0,0,0.2); min-width:200px; z-index:1000;">
        <a href="contacts.html" class="menu-item">üë• Contatos</a>
        <a href="#" class="menu-item" onclick="chooseWallpaper()">üñºÔ∏è Trocar Fundo de Tela</a>
        <a href="#" class="menu-item" onclick="deleteAllMessages()">üóëÔ∏è Apagar TODAS as Mensagens</a>
        <a href="#" class="menu-item" onclick="logout()">Sair</a>
    </div>
</div>

<div id="messages-container">
    <div id="videoCallArea">
        <video id="localVideo" autoplay playsinline muted></video>
        <button id="hangupBtn" onclick="hangUpCall()">üìû Desligar</button>
        <p style="position:absolute; top:10px; color:white; font-weight:bold;">Videochamada WebRTC</p>
        <video id="remoteVideo" autoplay playsinline style="width: 100px; height: 100px; position: absolute; top: 10px; right: 10px; z-index: 100; border-radius: 8px; border: 2px solid white; display:none;"></video>
    </div>
    <div id="messages"></div>
</div>

<div id="inputArea">
    <button id="fileBtn" class="btn">üìé</button>
    <input type="file" id="wallpaperInput" accept="image/*" style="display:none"> 
    <input type="file" id="fileInput" accept="video/*,image/*,audio/*" style="display:none">
    <button id="videoCallBtn" class="btn" title="Iniciar Videochamada">üìπ</button>
    <input id="textInput" placeholder="Mensagem">
    <button id="micBtn" class="btn">üé§</button>
    <button id="sendBtn" class="btn">‚û§</button>
</div>

<div id="loginModal">
    <div style="width:100%;max-width:320px;">
        <h2>Entrar</h2>
        <input id="email" placeholder="Email (seu nome de perfil)" style="width:100%;padding:10px;margin:6px 0;border-radius:6px;border:1px solid #ccc;">
        <input id="pass" placeholder="Senha" type="password" style="width:100%;padding:10px;margin:6px 0;border-radius:6px;border:1px solid #ccc;">
        <button onclick="login()">Entrar</button>
        <button onclick="register()">Registrar</button>
        <button onclick="reset()">Esqueci a senha</button>
        <p style="font-size:13px;color:#666;margin-top:10px;">Observa√ß√£o: teste em <strong>localhost</strong> ou via <em>HTTPS</em>. Chrome bloqueia c√¢mera/microfone em contexto inseguro.</p>
    </div>
</div>

<script>

/* ---------- CONFIGURA√á√ÉO SUPABASE (CHAVE UNIFICADA) ---------- */
const SUPABASE_URL = "https://dktkzsmfhhjxkbhvnwnw.supabase.co"; 
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRrdGt6c21maGhqeGtiaHZud253Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NDQ0MTQsImV4cCI6MjA4MDUyMDQxNH0.QpLkvWSaVPdjszXx0_epadmmfMRjwe_8C7WjcQzNbAs";

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: { persistSession: true }
});


/* ---------- Vari√°veis Globais de Estado e WebRTC ---------- */

let user = null;
let localStream = null;
let messagesDiv = document.getElementById('messages');
const loginModal = document.getElementById('loginModal');
const emailInput = document.getElementById('email');
const passInput = document.getElementById('pass');
const textInput = document.getElementById('textInput');
const fileInput = document.getElementById('fileInput');
const wallpaperInput = document.getElementById('wallpaperInput'); 
const videoCallArea = document.getElementById('videoCallArea');
const localVideo = document.getElementById('localVideo');
const micBtn = document.getElementById('micBtn'); 
const inputArea = document.getElementById('inputArea'); 

let peerConnection = null; 
let remoteVideo = null; 
let callChannel = null; 
let autoCallTargetId = null; 
let mediaRecorder = null; 
let audioChunks = []; 


const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun.services.mozilla.com' },
        { urls: 'stun:stun.stunprotocol.org' },
        { urls: 'stun:stun.voipbuster.com' },
        { urls: 'stun:stun.ideasip.com' },
        { urls: 'stun:stun.schlund.de' },
        {
            urls: 'turn:openrelay.metered.ca:443?transport=tcp', 
            username: 'openrelayproject',
            credential: 'openrelayproject'
        },
        {
            urls: 'turn:openrelay.metered.ca:443?transport=udp', 
            username: 'openrelayproject',
            credential: 'openrelayproject'
        }
    ]
};

remoteVideo = document.getElementById('remoteVideo');


// Adiciona funcionalidade aos bot√µes
document.getElementById('fileBtn').onclick = () => { if(!user){ alert('Fa√ßa login primeiro'); return; } fileInput.click(); };

// üö® L√≥gica de INICIAR/PARAR grava√ß√£o no clique do MIC
micBtn.onclick = () => { 
    if(!user){ alert('Fa√ßa login primeiro'); return; } 
    if(mediaRecorder && mediaRecorder.state === 'recording') {
        stopRecording();
    } else {
        startRecording();
    }
};

fileInput.onchange = (e) => { if(e.target.files[0]) uploadFile(e.target.files[0]); };
document.getElementById('sendBtn').onclick = sendMessage;
textInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendMessage(); });

document.getElementById('videoCallBtn').onclick = () => {
    if(!user){
        alert('Fa√ßa login para iniciar uma videochamada.');
        return;
    }
    let target = autoCallTargetId; 
    if (!target) {
        alert("Selecione um contato na lista de 'Contatos' para iniciar uma chamada.");
        window.location.href = 'contacts.html'; 
        return;
    }
    startVideoCall(target);
};


document.getElementById('kebabBtn').onclick = () => { const m = document.getElementById('kebabMenu'); m.style.display = m.style.display === 'block' ? 'none' : 'block'; };
document.addEventListener('click', (e)=>{ const m=document.getElementById('kebabMenu'); if(e.target.id!=='kebabBtn' && !m.contains(e.target)) m.style.display='none'; });


/* ---------- FUN√á√ïES AUXILIARES DE VIDEOCHAMADA ---------- */

function handleTrackEvent(event) {
    if (remoteVideo && event.streams && event.streams[0]) {
        remoteVideo.srcObject = event.streams[0];
        remoteVideo.style.display = 'block';
        console.log('Stream remoto recebido.');
    }
}

async function handleIceCandidateEvent(event, targetPeerId) {
    if (event.candidate) {
        console.log('Enviando candidato ICE:', event.candidate);
        await sb.channel('call_room_' + targetPeerId).send({
            type: 'broadcast',
            event: 'signal',
            payload: {
                senderId: user.id,
                targetId: targetPeerId,
                type: 'ice-candidate',
                candidate: event.candidate
            }
        });
    }
}

async function handleSignalMessage(payload) {
    const signal = payload.payload;
    if (signal.targetId !== user.id) return; 

    console.log('Sinal recebido:', signal.type, signal);

    if (signal.type === 'offer') {
        if(peerConnection){
            console.log('J√° em chamada. Ignorando nova oferta.');
            return; 
        }

        if (!confirm(`Chamada recebida de ${signal.senderId.substring(0, 8)}... Deseja atender?`)) {
            console.log("Chamada recusada.");
            return; 
        }

        await initializePeerConnection(signal.senderId); 
        await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        await sb.channel('call_room_' + signal.senderId).send({
            type: 'broadcast',
            event: 'signal',
            payload: {
                senderId: user.id,
                targetId: signal.senderId,
                type: 'answer',
                sdp: peerConnection.localDescription
            }
        });
    } else if (signal.type === 'answer') {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));
    } else if (signal.type === 'ice-candidate') {
        try {
            if(peerConnection && peerConnection.remoteDescription) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
            }
        } catch (e) {
            console.error('Erro ao adicionar candidato ICE:', e);
        }
    }
}

async function initializePeerConnection(targetPeerId) {
    if (peerConnection) return;
    
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    } catch(err) {
        console.error('Erro ao acessar m√≠dia (c√¢mera/microfone):', err);
        alert('Erro ao acessar c√¢mera/microfone. Verifique as permiss√µes. ' + (err.message || err.name));
        return; 
    }
    
    peerConnection = new RTCPeerConnection(iceServers);
    
    peerConnection.ontrack = handleTrackEvent;
    peerConnection.onicecandidate = (event) => handleIceCandidateEvent(event, targetPeerId); 

    localVideo.srcObject = localStream;
    localVideo.muted = true; 
    videoCallArea.style.display = 'flex';
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    
    remoteVideo.style.display = 'none'; 
    
    peerConnection.onconnectionstatechange = (event) => {
        console.log(`Estado da conex√£o WebRTC: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
              console.error("A conex√£o WebRTC falhou ou foi desconectada.");
        }
    };
}

// üö® FUN√á√ÉO CORRIGIDA PARA LIMPAR O ESTADO EM CASO DE ERRO DE SDP
async function startVideoCall(targetPeerId){
    if(!user || !targetPeerId){ 
        console.error('Usu√°rio ou alvo n√£o definido.');
        return; 
    }

    if(!isSecureContext()){
        alert('O WebRTC requer HTTPS. Teste em localhost ou por HTTPS.');
        return;
    }

    try{
        // 1. Inicializa a conex√£o (s√≥ executa se peerConnection for null)
        await initializePeerConnection(targetPeerId); 
        
        if(!peerConnection) return; 

        // 2. Cria a Offer (Proposta de conex√£o)
        const offer = await peerConnection.createOffer();
        
        // 3. Define a Offer localmente
        await peerConnection.setLocalDescription(offer);
        
        // 4. Envia o sinal para o alvo via Supabase
        await sb.channel('call_room_' + targetPeerId).send({
            type: 'broadcast',
            event: 'signal',
            payload: {
                senderId: user.id,
                targetId: targetPeerId,
                type: 'offer',
                sdp: peerConnection.localDescription
            }
        });

        alert(`Chamada iniciada. Tentando conectar com ${targetPeerId.substring(0, 8)}...`);

    }catch(err){
        console.error('Erro ao iniciar WebRTC:', err);
        
        // üö® CORRE√á√ÉO CR√çTICA: For√ßa a limpeza do objeto RTCPeerConnection em caso de erro 
        // de negocia√ß√£o (como o erro de SDP) para garantir que a pr√≥xima tentativa comece do zero.
        hangUpCall(); 
        
        alert('Erro ao iniciar chamada: ' + (err.message || err.name));
    }
}

function hangUpCall(){
    if(peerConnection){
        peerConnection.close();
        peerConnection = null;
    }
    
    if(localStream){
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
        localVideo.srcObject = null;
    }
    if(remoteVideo){
        remoteVideo.srcObject = null;
        remoteVideo.style.display = 'none';
    }
    videoCallArea.style.display = 'none';
    console.log('Chamada encerrada.');
    
    history.pushState(null, '', window.location.pathname);
    autoCallTargetId = null; 
}
window.hangUpCall = hangUpCall; 


/* ---------- GRAVA√á√ÉO E ENVIO DE √ÅUDIO (NOVO) ---------- */

async function startRecording() {
    if (!user) return;

    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        
        // Exibir indicador de grava√ß√£o (muda o √≠cone do bot√£o)
        micBtn.innerHTML = 'üî¥';
        micBtn.classList.add('recording-status');
        
        mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
            // Cria o Blob de √°udio e chama a fun√ß√£o de upload
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            
            // Reverter o bot√£o
            micBtn.innerHTML = 'üé§';
            micBtn.classList.remove('recording-status');
            
            // O stream de √°udio pode ser parado
            stream.getTracks().forEach(track => track.stop());
            
            // Chama a fun√ß√£o de upload (com o Blob e o prefixo de √°udio)
            uploadFile(audioBlob, true); 
        };

        mediaRecorder.start();
        textInput.placeholder = 'Gravando √°udio... Clique no microfone para parar.';
        console.log('Grava√ß√£o de √°udio iniciada.');

    } catch (err) {
        console.error('Erro ao iniciar grava√ß√£o de √°udio:', err);
        alert('Erro ao acessar microfone. Verifique as permiss√µes.');
        // Reverter o bot√£o
        micBtn.innerHTML = 'üé§';
        micBtn.classList.remove('recording-status');
    }
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        textInput.placeholder = 'Mensagem';
    }
}


/* ---------- OUTRAS FUN√á√ïES ---------- */

function chooseWallpaper() {
    if(!user){ alert('Fa√ßa login primeiro'); return; }
    wallpaperInput.click();
}
window.chooseWallpaper = chooseWallpaper;


wallpaperInput.onchange = (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            messagesDiv.style.backgroundImage = `url('${e.target.result}')`;
            alert('Fundo de tela alterado!');
        };
        reader.readAsDataURL(file);
    }
};


function isSecureContext() {
    return window.isSecureContext || location.hostname === "localhost" || location.hostname === "127.0.0.1";
}


/* ---------- AUTENTICA√á√ÉO ---------- */

async function login(){
    const email = emailInput.value.trim();
    const pass = passInput.value;
    if(!email || !pass){ alert('Preencha email e senha.'); return; }
    const { data, error } = await sb.auth.signInWithPassword({ email, password: pass });
    if(error){ alert('Erro: ' + (error.message || JSON.stringify(error))); return; }
    user = data.user;
}


async function register(){
    const email = emailInput.value.trim();
    const pass = passInput.value;
    if(!email.includes('@')){ alert('Email inv√°lido'); return; }
    const { data, error } = await sb.auth.signUp({ email, password: pass });
    if(error) alert('Erro no registro: ' + (error.message || JSON.stringify(error)));
    else alert('Registrado! Confirme o email e fa√ßa login.'); 
}


async function reset(){
    const email = emailInput.value.trim();
    if(!email.includes('@')){ alert('Email inv√°lido'); return; }
    const { data, error } = await sb.auth.resetPasswordForEmail(email);
    if(error) alert('Erro: ' + (error.message || JSON.stringify(error)));
    else alert('Email de recupera√ß√£o enviado!');
}


async function logout(){
    const { error } = await sb.auth.signOut();
    if(error) alert('Erro ao sair: ' + error.message);
    user = null;
    messagesDiv.innerHTML = '';
    loginModal.style.display = 'flex';
    document.getElementById('chatTitle').textContent = 'Chat V√≠deos';
    messagesDiv.style.backgroundImage = ''; 
    hangUpCall(); 
    
    history.pushState(null, '', window.location.pathname);
    autoCallTargetId = null;
}
window.logout = logout; 


/* ---------- EXCLUS√ÉO DE MENSAGENS INDIVIDUAL ---------- */

window.openMessageMenu = function(e, msg) {
    if(!user || msg.user_id !== user.id) return; 
    const confirmed = confirm(`Deseja apagar esta mensagem (ID: ${msg.id})?`); 
    if (confirmed) {
        deleteMessage(msg.id);
    }
    e.stopPropagation(); 
};


async function deleteMessage(messageId){
    if(!user) return;

    const { error } = await sb.from('messages')
        .delete()
        .eq('id', messageId)
        .eq('user_id', user.id); 

    if(error){ 
        alert('Erro ao apagar mensagem: ' + error.message);
        console.error(error);
    } else {
        const el = document.querySelector(`[data-message-id="${messageId}"]`);
        if(el) {
            const groupEl = el.closest('.msg-group');
            if(groupEl) groupEl.remove();
        }
    }
}
window.deleteMessage = deleteMessage;


/* ---------- EXCLUS√ÉO EM MASSA DE MENSAGENS ---------- */

async function deleteAllMessages(){
    if(!user){
        alert('Fa√ßa login primeiro.');
        return;
    }
    
    const confirmed = confirm("‚ö†Ô∏è ATEN√á√ÉO: Deseja REALMENTE apagar TODAS as suas mensagens no chat? Esta a√ß√£o √© irrevers√≠vel.");
    if (!confirmed) return;
    
    const { error } = await sb.from('messages')
        .delete()
        .eq('user_id', user.id); 

    if(error){ 
        alert('Erro ao apagar mensagens: ' + error.message);
        console.error(error);
    } else {
        messagesDiv.innerHTML = '';
        alert('Todas as suas mensagens foram apagadas com sucesso! (Recarregue para garantir a sincroniza√ß√£o em tempo real).');
    }
}
window.deleteAllMessages = deleteAllMessages; 


/* ---------- RENDER MENSAGENS (CORRIGIDA PARA √ÅUDIO) ---------- */

function renderMessage(msg){
    const date = new Date(msg.created_at);
    const timeString = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    const profileName = msg.user_id === user.id ? 'Voc√™' : (msg.email || msg.user_id); 
    
    const groupDiv = document.createElement('div');
    groupDiv.className = 'msg-group ' + ((user && msg.user_id === user.id) ? 'me':'other');

    const nameSpan = document.createElement('span');
    nameSpan.className = 'profile-name';
    nameSpan.textContent = profileName; 
    groupDiv.appendChild(nameSpan);

    const div = document.createElement('div');
    div.className = 'msg ' + ((user && msg.user_id === user.id) ? 'me':'other');
    
    div.dataset.messageId = msg.id; 
    div.onclick = (e) => openMessageMenu(e, msg);

    let content = msg.text || '';
    const prefixes = { '[√Åudio]:':'audio', '[Imagem]:':'image', '[V√≠deo]:':'video', '[Arquivo]:':'file' };
    for(const p in prefixes){
        if(content.startsWith(p)){
            const type = prefixes[p];
            const path = content.substring(p.length).trim();
            
            // Obter URL p√∫blico do Bucket 'messages'
            const { data: urlData } = sb.storage.from('messages').getPublicUrl(path); 
            const fileUrl = urlData.publicUrl;
            
            if(type === 'image') {
                content = `<div class="file-content">üñºÔ∏è <a href="${fileUrl}" target="_blank"><img src="${fileUrl}" alt="imagem" style="max-width:220px;border-radius:6px"></a></div>`;
            } else if(type === 'video') {
                content = `<div class="file-content">üìπ<video controls style="max-width:240px;border-radius:6px"><source src="${fileUrl}">Seu navegador n√£o suporta.</video></div>`;
            } else if(type === 'audio') {
                // Renderiza o reprodutor de √°udio
                content = `<div class="file-content">üé§<audio controls src="${fileUrl}" style="max-width:240px"></audio></div>`;
            } else {
                const fileName = path.split('/').pop();
                content = `<div class="file-content">üì¶ <a href="${fileUrl}" target="_blank" download>${fileName}</a></div>`;
            }
            break;
        }
    }

    div.innerHTML = `${content}<span class="timestamp">${timeString}</span>`;
    groupDiv.appendChild(div);
    
    messagesDiv.appendChild(groupDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}


/* ---------- INSERIR E CARREGAR HIST√ìRICO ---------- */

async function sendMessage(){
    const text = textInput.value.trim();
    if(!text || !user) return;
    const { error } = await sb.from('messages').insert({ user_id: user.id, text, email: user.email }); 
    if(error) alert('Erro ao enviar: ' + error.message);
    else textInput.value = '';
}


async function loadHistory(){
    const { data, error } = await sb.from('messages').select('*').order('created_at', { ascending: true });
    if(error){ console.error(error); alert('Erro ao carregar hist√≥rico'); return; }
    messagesDiv.innerHTML = '';
    data.forEach(renderMessage);
}


/* ---------- SUBSCRIBE (Realtime Otimizado) ---------- */

function subscribeToMessages(){
    if(window.chatChannel) {
        sb.removeChannel(window.chatChannel);
        console.log('Canal Realtime anterior removido.');
    }
    
    window.chatChannel = sb.channel('public:messages')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
            if(payload && payload.new) renderMessage(payload.new);
        })
        .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
                 console.log('Realtime Messages: SUBSCRIBED');
            }
        });
}


/* ---------- UPLOAD (CORRIGIDO PARA O BUCKET 'messages' e √ÅUDIO) ---------- */

async function uploadFile(file, isAudio = false){
    if(!file || !user) return;
    
    let mimeType = file.type || '';
    if(isAudio) mimeType = 'audio/webm'; 

    let prefix = '[Arquivo]: ';
    if(isAudio) prefix = '[√Åudio]: '; 
    else if(mimeType.startsWith('video/')) prefix = '[V√≠deo]: ';
    else if(mimeType.startsWith('image/')) prefix = '[Imagem]: ';
    
    
    const fileExtension = isAudio ? 'webm' : (file.name.split('.').pop() || 'dat');
    const safeName = file.name.replace(/[^a-z0-9.]/gi, '_').toLowerCase() || 'audio';
    const path = `${user.id}/${Date.now()}_${safeName}.${fileExtension}`;
    
    // Usa o Bucket CORRETO 'messages'
    const { data: uploadData, error: uploadError } = await sb.storage
        .from('messages') 
        .upload(path, file, { 
            cacheControl: '3600', 
            upsert: false, 
            contentType: mimeType 
        });
        
    if(uploadError){ 
        console.error(uploadError); 
        alert('Erro no upload: ' + uploadError.message); 
        return; 
    }
    
    const { error: dbError } = await sb.from('messages').insert({ user_id: user.id, text: `${prefix}${uploadData.path}`, email: user.email }); 
    if(dbError) alert('Erro ao gravar mensagem: ' + dbError.message);
    
    // Limpar o input file apenas se n√£o for um Blob de √°udio
    if(!isAudio) fileInput.value = '';
}


// Fun√ß√£o para obter par√¢metros da URL 
function getUrlParameter(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    const results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};


/* ---------- FUN√á√ÉO DE NOTIFICA√á√ÉO PUSH ---------- */

function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}


async function subscribeUserToPush() {
    const PUBLIC_VAPID_KEY = 'BMaR3zFqEh_OVdJSDBEWokPLjYg0LxausOc9VrQj_FKwW869k7rK07M_bLbrE3WoVYkA0tkK-DwssC4K2I9BJ2U'; 

    if (!('serviceWorker' in navigator) || !('PushManager' in window) || !user) {
        console.warn('Push not supported or user not logged in.');
        return;
    }

    console.log(`‚û°Ô∏è Status da permiss√£o de Notifica√ß√£o atual: ${Notification.permission}`);

    try {
        const swReg = await navigator.serviceWorker.register('service-worker.js');
        console.log('‚úÖ Service Worker registrado com sucesso!');

        if (Notification.permission === 'default') {
            const permissionResult = await Notification.requestPermission();
            console.log(`Novo status da permiss√£o: ${permissionResult}`);
            if (permissionResult !== 'granted') {
                console.log('üõë Permiss√£o negada pelo usu√°rio.');
                return;
            }
        } else if (Notification.permission === 'denied') {
            console.log('üõë Permiss√£o negada anteriormente. Usu√°rio deve resetar manualmente.');
            return;
        }

        const applicationServerKey = urlBase64ToUint8Array(PUBLIC_VAPID_KEY);
        const subscription = await swReg.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: applicationServerKey
        });

        console.log('‚úÖ Objeto de subscri√ß√£o Push criado (Token gerado):', subscription);

        const { error: dbError } = await sb.from('user_subscriptions').upsert({
            user_id: user.id,
            subscription_data: subscription,
            updated_at: new Date().toISOString() 
        }, { onConflict: 'user_id' }); 

        if (dbError) {
            console.error('üõë Falha ao salvar inscri√ß√£o Push no Supabase:', dbError);
            alert('Erro: ' + dbError.message);
        } else {
            console.log('‚úÖ Inscri√ß√£o Push salva com sucesso no Supabase!');
        }

    } catch (err) {
        console.error('Falha na inscri√ß√£o Push. Detalhes:', err);
        if (err.name === 'NotAllowedError') {
            alert('Notifica√ß√µes bloqueadas. Habilite nas configura√ß√µes do navegador.');
        } else {
            alert('Erro ao registrar Push: ' + err.message);
        }
    }
}


/* ---------- L√≥gica de subscri√ß√£o e in√≠cio de chamada autom√°tica ---------- */

function setupCallChannelAndStartAutoCall() {
    if (!user) return; 
    
    if (!callChannel) {
        callChannel = sb.channel('call_room_' + user.id);
        callChannel.on('broadcast', { event: 'signal' }, handleSignalMessage).subscribe((status) => {
            if (status === 'SUBSCRIBED') {
                console.log(`Pronto para receber chamadas no canal: call_room_${user.id}`);
                if (autoCallTargetId && autoCallTargetId !== user.id) {
                    startVideoCall(autoCallTargetId);
                }
            }
        });
    } else {
        if (autoCallTargetId && autoCallTargetId !== user.id) {
              startVideoCall(autoCallTargetId);
        }
    }
}


/* ---------- INICIALIZA√á√ÉO ---------- */

function initializeChat(event_type = 'SESSION_RECOVERED'){
    
    autoCallTargetId = getUrlParameter('target');
    
    if(user){
        loginModal.style.display = 'none';
        document.getElementById('chatTitle').textContent = user.email.split('@')[0];
        loadHistory();
        subscribeToMessages();
        
        if(event_type !== 'SIGNED_IN') {
             subscribeUserToPush(); 
        }

        if (autoCallTargetId === user.id) {
            alert("Voc√™ n√£o pode ligar para si mesmo.");
            history.pushState(null, '', window.location.pathname);
            autoCallTargetId = null; 
        } else {
            setupCallChannelAndStartAutoCall();
        }

    } else {
        loginModal.style.display = 'flex';
        history.pushState(null, '', window.location.pathname);
        autoCallTargetId = null;
    }
}

sb.auth.onAuthStateChange(async (event, session) => {
    user = session?.user || null;
    
    if (user) {
        if (event === 'SIGNED_IN') {
             alert('Bem-vindo! Para receber alertas de chamadas e mensagens quando o aplicativo n√£o estiver aberto, clique em "Permitir" na pr√≥xima notifica√ß√£o.');
             initializeChat('SIGNED_IN'); 
             await subscribeUserToPush();
        } else if (event === 'INITIAL_SESSION' || event === 'TOKEN_REFRESHED' || event === 'USER_UPDATED') {
             initializeChat('SESSION_RECOVERED');
        }
    } else if (event === 'SIGNED_OUT') {
        loginModal.style.display = 'flex';
    }
});


sb.auth.getSession().then(({ data: { session } }) => {
    if(!session) {
         initializeChat('NO_SESSION'); 
    }
});

window.login = login; window.register = register; window.reset = reset;

</script>


</body>
</html>
