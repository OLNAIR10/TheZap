<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Chat de V√≠deos - TheZap</title>
    <!-- Carrega a biblioteca do Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Vari√°veis de Cores (WhatsApp-like) */
        :root {
            --bg-color: #e5ddd5;
            --message-bg-received: #fff;
            --message-bg-sent: #dcf8c6;
            --header-bg: #075e54;
            --text-color: #4a4a4a;
            --accent-color: #25d366;
            --button-danger: #d9534f;
            --border-color: #eee;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: Arial, sans-serif;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #topbar {
            height: 56px;
            background: var(--header-bg);
            display: flex;
            align-items: center;
            padding: 0 12px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            justify-content: space-between;
            position: relative;
            z-index: 200;
        }

        #kebabMenu {
            display: none;
            position: absolute;
            top: 50px;
            right: 5px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            min-width: 200px;
            z-index: 1000;
        }

        .menu-item {
            display: block;
            padding: 10px 15px;
            text-decoration: none;
            color: var(--text-color);
            border-bottom: 1px solid var(--border-color);
        }

        .menu-item:hover {
            background-color: #f0f0f0;
        }

        /* √Årea de V√≠deo WebRTC */
        #video-container {
            position: relative;
            background-color: #000;
            height: 250px; /* Altura fixa para mobile */
            display: none; /* Inicia oculto */
            width: 100%;
            z-index: 10;
        }

        #localVideo {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 75px;
            border-radius: 8px;
            border: 2px solid #fff;
            object-fit: cover;
            z-index: 100;
        }

        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Bot√£o de Desligar (Chamada) */
        #hangup-button {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--button-danger);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 110;
        }

        /* √Årea Principal de Chat */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            /* Fundo inicial, ser√° trocado via JS */
            background-image: url('https://placehold.co/400x800/e5ddd5/e5ddd5?text=');
            background-size: cover;
            background-position: center;
        }

        /* Cont√™iner de Mensagem */
        .message-container {
            display: flex;
            margin-bottom: 5px;
        }

        .message-received {
            justify-content: flex-start;
        }

        .message-sent {
            justify-content: flex-end;
        }

        /* Bal√£o da Mensagem */
        .message-bubble {
            max-width: 80%;
            padding: 8px 10px;
            border-radius: 8px;
            line-height: 1.4;
            font-size: 14px;
            position: relative;
            box-shadow: 0 1px 0.5px rgba(0,0,0,0.1);
        }

        .message-received .message-bubble {
            background-color: var(--message-bg-received);
            color: var(--text-color);
            margin-left: 10px;
            border-bottom-left-radius: 0;
        }

        .message-sent .message-bubble {
            background-color: var(--message-bg-sent);
            color: var(--text-color);
            margin-right: 10px;
            border-bottom-right-radius: 0;
        }

        .message-time {
            display: block;
            text-align: right;
            font-size: 10px;
            color: rgba(0, 0, 0, 0.45);
            margin-top: 3px;
        }

        /* √Årea de Input */
        #chat-input {
            display: flex;
            padding: 8px;
            background-color: var(--bg-color);
            align-items: center;
        }

        #message-input {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 20px;
            border: none;
            font-size: 16px;
            margin-right: 8px;
            box-shadow: 0 1px 0.5px rgba(0,0,0,0.1);
        }

        #send-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Estilo para o √≠cone de menu kebab */
        #kebab-icon {
            cursor: pointer;
            padding: 8px;
            font-size: 24px;
        }
    </style>
</head>
<body>

<div id="topbar">
    <span id="display-user-name">Carregando...</span>
    <div style="position: relative;">
        <span id="kebab-icon" onclick="toggleKebabMenu()">&#x22EE;</span>
        <!-- MENU KEBAB ATUALIZADO (Inclui links para as novas p√°ginas) -->
        <div id="kebabMenu">
            <!-- Lista para Videochamada -->
            <a href="contacts.html" class="menu-item">üë• Contatos (Videochamada)</a>
            
            <!-- Link para Contatos de Chat Privado -->
            <a href="chat_contacts.html" class="menu-item">üí¨ Contatos (Chat Privado)</a>

            <a href="#" class="menu-item" onclick="chooseWallpaper()">üñºÔ∏è Trocar Fundo de Tela</a>
            <a href="#" class="menu-item" onclick="deleteAllMessages()">üóëÔ∏è Apagar TODAS as Mensagens</a>
            <a href="#" class="menu-item" onclick="logout()">Sair</a>
        </div>
    </div>
</div>

<!-- √Årea de V√≠deo (Inicialmente oculta) -->
<div id="video-container">
    <video id="remoteVideo" autoplay playsinline></video>
    <video id="localVideo" autoplay muted playsinline></video>
    <button id="hangup-button" onclick="hangup()">Desligar</button>
</div>

<!-- √Årea de Mensagens -->
<div id="chat-messages">
    <p style="text-align:center; color:gray; padding-top:20px;">
        Conectando ao Supabase...
    </p>
</div>

<!-- √Årea de Input -->
<div id="chat-input">
    <input type="text" id="message-input" placeholder="Mensagem">
    <button id="send-button" onclick="sendMessage()">‚ñ∂</button>
</div>

<script>
// ---------- CONFIGURA√á√ÉO INICIAL E CONSTANTES ----------
const SUPABASE_URL = "https://oggzsjqwxqlqejcyakli.supabase.co"; 
const SUPABASE_KEY ="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9nZ3pzanF3eHFscWVqY3lha2xpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ2NzA3NDQsImV4cCI6MjA4MDI0Njc0NH0.LPdgQmoN-gE8EWxwEd4NBufbzrp1uQTYq2KicwDlgaQ";

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
const chatMessages = document.getElementById('chat-messages');
const messageInput = document.getElementById('message-input');
const displayUserName = document.getElementById('display-user-name');
const videoContainer = document.getElementById('video-container');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

let userId = null;
let currentChatPartnerId = null; 
let currentChannel = null; // Canal de chat do Supabase
let isPrivateChat = false;

// Vari√°veis WebRTC
let peerConnection = null;
let localStream = null;
let isVideoCallActive = false;

// O √öLTIMO ENDERE√áO IP (PARA SIMULAR LOGOUT E LOGIN)
let lastKnownIp = null;

// ---------- CONFIGURA√á√ÉO WEB RTC COM STUN E TURN (ROBUSTEZ M√ÅXIMA) ----------
const peerConnectionConfig = {
    iceServers: [
        // 1. SERVIDORES STUN (Tenta a conex√£o P2P direta)
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun.services.mozilla.com' },
        { urls: 'stun:stun.stunprotocol.org' },
        { urls: 'stun:stun.voip.blackberry.com' },
        { urls: 'stun:stun.nextcloud.com:443' }, 
        { urls: 'stun:stunserver.org' },
        
        // 2. SERVIDOR TURN (Retransmissor de dados para NATs sim√©tricos/restritivos)
        // Credenciais p√∫blicas de teste (usar com cautela, apenas para prot√≥tipo)
        {
            urls: 'turn:openrelay.metered.ca:443?transport=tcp', // TURN via TCP (mais chance de furar firewall)
            username: 'openrelayproject',
            credential: 'openrelayproject'
        },
        {
            urls: 'turn:openrelay.metered.ca:443?transport=udp', // TURN via UDP
            username: 'openrelayproject',
            credential: 'openrelayproject'
        }
    ]
};


// ---------- FUN√á√ïES DE AUTENTICA√á√ÉO E INICIALIZA√á√ÉO ----------

async function initializeAuth() {
    const { data: sessionData } = await sb.auth.getSession();
    const user = sessionData?.session?.user;

    if (user) {
        userId = user.id;
        // Tenta obter o nome de exibi√ß√£o do perfil
        const { data: profile } = await sb.from('profiles').select('email').eq('id', userId).single();
        const userName = profile?.email ? profile.email.split('@')[0] : 'Usu√°rio An√¥nimo';
        displayUserName.textContent = userName;
        
        // Verifica se h√° um target para chat privado ou videochamada
        const urlParams = new URLSearchParams(window.location.search);
        const targetIdFromUrl = urlParams.get('target');
        const targetIdFromHash = window.location.hash.substring(1);

        if (targetIdFromUrl) {
            // Inicia videochamada
            currentChatPartnerId = targetIdFromUrl;
            startVideoCall(true); // true = √© o chamador
        } else if (targetIdFromHash && targetIdFromHash.length > 5) {
            // Entra em chat privado (exclui chats de 1 ou 2 caracteres)
            currentChatPartnerId = targetIdFromHash;
            isPrivateChat = true;
            initializeChat();
        } else {
            // Chat p√∫blico (canal padr√£o)
            initializeChat();
        }

    } else {
        // Redireciona para o login ou permite login an√¥nimo
        displayUserName.textContent = 'Visitante';
        promptForLogin();
    }
}

async function promptForLogin() {
    // Implementa√ß√£o simplificada de login/signup para demonstra√ß√£o
    const email = prompt("Bem-vindo! Digite seu e-mail para Entrar/Cadastrar:");
    if (!email) return;

    try {
        // Tenta logar (se existir) ou registrar (se for novo)
        const { error: signInError } = await sb.auth.signInWithOtp({ 
            email,
            options: {
                emailRedirectTo: window.location.origin, // Retorna para esta p√°gina
            }
        });

        if (signInError) throw signInError;
        alert("Verifique seu e-mail para o link de login! Ap√≥s clicar, recarregue esta p√°gina.");
    } catch (error) {
        console.error("Erro de Autentica√ß√£o:", error.message);
        alert(`Erro de Autentica√ß√£o: ${error.message}`);
    }
}

function logout() {
    sb.auth.signOut();
    alert('Voc√™ foi desconectado.');
    window.location.reload();
}

// ---------- FUN√á√ïES DE CHAT DE TEXTO ----------

// Gera um ID de canal consistente (ID1_ID2) para chat privado
function generateChatChannelId(user1Id, user2Id) {
    // Ordena os IDs para garantir que o ID do canal seja sempre o mesmo
    return [user1Id, user2Id].sort().join('_');
}

async function initializeChat() {
    let channelName;

    if (isPrivateChat && currentChatPartnerId) {
        // Chat Privado: o ID do canal √© baseado nos dois IDs de usu√°rio
        channelName = generateChatChannelId(userId, currentChatPartnerId);
        displayUserName.textContent = `Chat Privado: ${displayUserName.textContent.split(':')[0]} ‚Üî ${currentChatPartnerId.substring(0, 8)}...`;
    } else {
        // Chat P√∫blico: Canal fixo
        channelName = 'chat_publico_global';
        displayUserName.textContent = `Chat P√∫blico: ${displayUserName.textContent}`;
    }

    // 1. Carrega mensagens antigas
    await loadMessages(channelName);

    // 2. Assina o canal para novas mensagens
    currentChannel = sb.channel(channelName);

    currentChannel.on('postgres_changes', { 
        event: 'INSERT', 
        schema: 'public', 
        table: 'messages',
        filter: `channel_id=eq.${channelName}`
    }, (payload) => {
        // Adiciona a nova mensagem √† interface
        renderMessage(payload.new);
        scrollToBottom();
    }).subscribe();

    // Adiciona listener para enviar mensagem com a tecla Enter
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    scrollToBottom();
}

// Carrega as √∫ltimas 50 mensagens do canal
async function loadMessages(channelId) {
    chatMessages.innerHTML = '';
    const { data, error } = await sb.from('messages')
        .select('*')
        .eq('channel_id', channelId)
        .order('created_at', { ascending: true })
        .limit(50);

    if (error) {
        chatMessages.innerHTML = `<p style="text-align:center; color:red;">Erro ao carregar mensagens: ${error.message}</p>`;
        return;
    }

    data.forEach(renderMessage);
}

function renderMessage(message) {
    const isSent = message.sender_id === userId;
    const container = document.createElement('div');
    container.className = `message-container ${isSent ? 'message-sent' : 'message-received'}`;

    const bubble = document.createElement('div');
    bubble.className = 'message-bubble';

    let content = message.content;
    
    // Adiciona o nome do remetente (apenas para mensagens recebidas)
    if (!isSent) {
        const senderName = document.createElement('strong');
        senderName.textContent = `${message.sender_name || 'Usu√°rio'}: `;
        bubble.appendChild(senderName);
    }

    const text = document.createTextNode(content);
    bubble.appendChild(text);

    const time = document.createElement('span');
    time.className = 'message-time';
    time.textContent = new Date(message.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    bubble.appendChild(time);
    
    container.appendChild(bubble);
    chatMessages.appendChild(container);
}

function scrollToBottom() {
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

async function sendMessage() {
    if (!messageInput.value.trim() || !userId) return;

    const content = messageInput.value.trim();
    const senderName = displayUserName.textContent.split(': ')[0].split(' ‚Üî ')[0]; // Limpa o nome para pegar s√≥ o prefixo

    const { error } = await sb.from('messages').insert([
        { 
            content: content, 
            sender_id: userId,
            sender_name: senderName,
            channel_id: currentChannel.name 
        }
    ]);

    if (error) {
        console.error('Erro ao enviar mensagem:', error);
    } else {
        messageInput.value = ''; // Limpa o input
    }
}

async function deleteAllMessages() {
    if (!confirm("Tem certeza que deseja apagar TODAS as mensagens deste canal? Esta a√ß√£o √© irrevers√≠vel.")) {
        return;
    }

    const { error } = await sb.from('messages')
        .delete()
        .eq('channel_id', currentChannel.name);

    if (error) {
        alert('Erro ao apagar mensagens: ' + error.message);
    } else {
        chatMessages.innerHTML = '<p style="text-align:center; color:gray; padding-top:20px;">Mensagens apagadas com sucesso!</p>';
    }
}

// ---------- FUN√á√ïES DE PERSONALIZA√á√ÉO ----------

function chooseWallpaper() {
    const wallpapers = [
        'https://placehold.co/400x800/d9fcd1/d9fcd1?text=Pattern_1', // Fundo claro (padr√£o WhatsApp)
        'https://placehold.co/400x800/223437/223437?text=Pattern_2', // Fundo escuro
        'https://placehold.co/400x800/a3ccff/a3ccff?text=Pattern_3', // Fundo azul claro
        'https://picsum.photos/400/800/?blur=5', // Imagem real desfocada
    ];
    
    const choice = prompt(
        "Escolha um n√∫mero para trocar o fundo de tela:\n" +
        "1: Padr√£o Claro\n" +
        "2: Padr√£o Escuro\n" +
        "3: Padr√£o Azul\n" +
        "4: Imagem Aleat√≥ria"
    );

    let wallpaperUrl;
    if (choice === '1') wallpaperUrl = wallpapers[0];
    else if (choice === '2') wallpaperUrl = wallpapers[1];
    else if (choice === '3') wallpaperUrl = wallpapers[2];
    else if (choice === '4') wallpaperUrl = wallpapers[3];
    else {
        alert("Escolha inv√°lida.");
        return;
    }

    chatMessages.style.backgroundImage = `url('${wallpaperUrl}')`;
}

// ---------- FUN√á√ïES DE UTILIDADE DE UI ----------

function toggleKebabMenu() {
    const menu = document.getElementById('kebabMenu');
    menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
}

// ---------- FUN√á√ïES DE VIDEOCHAMADA (WEBRTC) ----------

// Fun√ß√£o para obter o stream de m√≠dia (c√¢mera/microfone)
async function getMediaStream() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = stream;
        localStream = stream;
        return stream;
    } catch (err) {
        console.error("Erro ao acessar c√¢mera/microfone:", err);
        // Exibe uma mensagem mais informativa na interface do usu√°rio (n√£o um alert feio)
        alert('Erro ao iniciar c√¢mera/chamada: Por favor, verifique as permiss√µes do seu navegador.');
        return null;
    }
}

// Gerencia o canal de sinaliza√ß√£o no Supabase
function getSignalChannel(isCaller) {
    // Cria um ID de canal de sinaliza√ß√£o √∫nico para a dupla (A-B)
    const signalChannelId = [userId, currentChatPartnerId].sort().join('-');
    
    // Configura o canal de broadcast do Supabase (para enviar a sinaliza√ß√£o)
    // O 'self: false' garante que o remetente n√£o receba a pr√≥pria mensagem
    const channel = sb.channel(signalChannelId, { config: { broadcast: { self: false } } });
    
    // Listener para mensagens de sinaliza√ß√£o (SDP e ICE)
    channel.on('broadcast', { event: 'webrtc-signal' }, (payload) => {
        const signal = payload.payload;
        
        if (signal.type === 'offer' && !isCaller) {
            // Recebeu oferta (o receptor)
            handleOffer(signal.sdp);
        } else if (signal.type === 'answer' && isCaller) {
            // Recebeu resposta (o chamador)
            peerConnection.setRemoteDescription(new RTCSessionDescription({ type: signal.type, sdp: signal.sdp }));
        } else if (signal.type === 'ice') {
            // Recebeu candidato ICE
            if (peerConnection.remoteDescription) {
                // Adiciona o candidato ICE se o SDP remoto j√° foi configurado
                 peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice));
            }
        }
    }).subscribe();

    return channel;
}

// Envia a sinaliza√ß√£o (offer, answer, ice) para o Supabase
function sendSignal(type, payload) {
    if (!currentChannel) return;

    currentChannel.send({
        type: 'broadcast',
        event: 'webrtc-signal',
        payload: { type, ...payload }
    });
}

// 1. Inicializa a conex√£o WebRTC (ambos os lados)
function initializePeerConnection(stream) {
    // Tenta usar a configura√ß√£o robusta (STUN + TURN)
    peerConnection = new RTCPeerConnection(peerConnectionConfig);

    // Adiciona o stream local √† conex√£o
    stream.getTracks().forEach(track => {
        peerConnection.addTrack(track, stream);
    });

    // 2. Ouve por candidatos ICE (endere√ßos de rede) e envia para o parceiro
    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            sendSignal('ice', { ice: event.candidate });
        }
    };

    // 3. Recebe o stream remoto do parceiro e mostra na tela
    peerConnection.ontrack = (event) => {
        if (remoteVideo.srcObject !== event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
        }
    };

    // Ouve a mudan√ßa de estado de conex√£o para diagn√≥stico
    peerConnection.onconnectionstatechange = (event) => {
        console.log(`Estado da conex√£o WebRTC: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'connected') {
            console.log("Conex√£o WebRTC estabelecida com sucesso!");
        } else if (peerConnection.connectionState === 'failed') {
             console.error("A conex√£o WebRTC falhou. Tente novamente.");
        }
    };
}

// Inicia a videochamada (lado do chamador)
async function startVideoCall(isCaller) {
    if (isVideoCallActive) {
        console.warn('Uma chamada j√° est√° em andamento.');
        return;
    }
    
    // 1. Obt√©m a m√≠dia local
    const stream = await getMediaStream();
    if (!stream) return;

    // 2. Configura a UI
    videoContainer.style.display = 'block';
    isVideoCallActive = true;
    chatMessages.style.display = 'none';
    document.getElementById('chat-input').style.display = 'none';

    // 3. Configura o canal de sinaliza√ß√£o e o PeerConnection
    currentChannel = getSignalChannel(isCaller);
    initializePeerConnection(stream);
    
    if (isCaller) {
        // 4A. Se for o chamador, cria e envia a OFERTA (Offer)
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        sendSignal('offer', { sdp: peerConnection.localDescription.sdp });
        alert(`Chamada iniciada. Tentando conectar com ${currentChatPartnerId.substring(0, 8)}...`);
    }
}

// Lida com a oferta recebida (lado do receptor)
async function handleOffer(sdp) {
    if (isVideoCallActive) return; // N√£o aceita nova chamada se j√° estiver em uma

    // Pergunta ao usu√°rio se ele quer aceitar a chamada
    if (!confirm(`Recebendo chamada de ${currentChatPartnerId.substring(0, 8)}... Deseja atender?`)) {
        hangup(); // Se recusar, desliga tudo
        return;
    }

    // 1. Obt√©m a m√≠dia local (Aceitou)
    const stream = await getMediaStream();
    if (!stream) return;

    // 2. Configura a UI
    videoContainer.style.display = 'block';
    isVideoCallActive = true;
    chatMessages.style.display = 'none';
    document.getElementById('chat-input').style.display = 'none';

    // 3. Configura o canal e o PeerConnection (lado receptor)
    currentChannel = getSignalChannel(false); // false = n√£o √© o chamador
    initializePeerConnection(stream);
    
    // 4. Configura a descri√ß√£o remota com a oferta
    await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp }));
    
    // 5. Cria a RESPOSTA (Answer)
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    
    // 6. Envia a RESPOSTA de volta para o chamador
    sendSignal('answer', { sdp: peerConnection.localDescription.sdp });
}

// Finaliza a chamada
function hangup() {
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    
    // Cancela a inscri√ß√£o do canal de sinaliza√ß√£o
    if (currentChannel) {
        sb.removeChannel(currentChannel);
        currentChannel = null;
    }
    
    // Limpa a UI
    localVideo.srcObject = null;
    remoteVideo.srcObject = null;
    videoContainer.style.display = 'none';
    chatMessages.style.display = 'flex';
    document.getElementById('chat-input').style.display = 'flex';

    isVideoCallActive = false;
    currentChatPartnerId = null; // Zera o target
    isPrivateChat = false;
    
    // Retorna ao chat p√∫blico
    if (window.location.hash || window.location.search) {
        window.location.href = window.location.origin + window.location.pathname; // Remove par√¢metros/hash
    } else {
        // Se j√° estava no chat p√∫blico, apenas reinicializa
        initializeChat();
    }
}

// ---------- INICIALIZA√á√ÉO ----------
document.addEventListener('DOMContentLoaded', initializeAuth);
</script>
</body>
</html>

